# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  firstName: String
  lastName: String
  email: String
  ip: String
  userAuth: UserAuth
  roles(
    where: RoleWhereInput! = {}
    orderBy: [RoleOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Role!]
  rolesCount(where: RoleWhereInput! = {}): Int
  password: PasswordState
  isAdmin: Boolean
  isSubscribedToEmail: Boolean
  isNotChargeable: Boolean
  isVerified: Boolean
  subscription: Subscription
  referrer: String
  referralCode: String
  walletAddress: String
  content(
    where: ContentWhereInput! = {}
    orderBy: [ContentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Content!]
  contentCount(where: ContentWhereInput! = {}): Int
  projects(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  managedProjects(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  managedProjectsCount(where: ProjectWhereInput! = {}): Int
  marketingCampaigns(
    where: MarketingCampaignWhereInput! = {}
    orderBy: [MarketingCampaignOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [MarketingCampaign!]
  marketingCampaignsCount(where: MarketingCampaignWhereInput! = {}): Int
  followedProviders(
    where: ProviderWhereInput! = {}
    orderBy: [ProviderOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Provider!]
  followedProvidersCount(where: ProviderWhereInput! = {}): Int
  serviceTokens: ServiceToken
  providerProfile: Provider
  dateCreated: DateTime
  subscriptionStatus(userId: ID): subscriptionStatus
  passwordResetToken: PasswordState
  passwordResetIssuedAt: DateTime
  passwordResetRedeemedAt: DateTime
}

type PasswordState {
  isSet: Boolean!
}

scalar DateTime
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

type subscriptionStatus {
  isValid: Boolean
  products: JSON
  dateFrom: DateTime
  dateTo: DateTime
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  email: StringFilter
  ip: StringFilter
  userAuth: UserAuthWhereInput
  roles: RoleManyRelationFilter
  isAdmin: BooleanFilter
  isSubscribedToEmail: BooleanFilter
  isNotChargeable: BooleanFilter
  isVerified: BooleanFilter
  subscription: SubscriptionWhereInput
  referrer: StringFilter
  referralCode: StringFilter
  walletAddress: StringFilter
  content: ContentManyRelationFilter
  projects: ProjectManyRelationFilter
  managedProjects: ProjectManyRelationFilter
  marketingCampaigns: MarketingCampaignManyRelationFilter
  followedProviders: ProviderManyRelationFilter
  serviceTokens: ServiceTokenWhereInput
  providerProfile: ProviderWhereInput
  dateCreated: DateTimeNullableFilter
  passwordResetToken: PasswordFilter
  passwordResetIssuedAt: DateTimeNullableFilter
  passwordResetRedeemedAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input RoleManyRelationFilter {
  every: RoleWhereInput
  some: RoleWhereInput
  none: RoleWhereInput
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input ContentManyRelationFilter {
  every: ContentWhereInput
  some: ContentWhereInput
  none: ContentWhereInput
}

input ProjectManyRelationFilter {
  every: ProjectWhereInput
  some: ProjectWhereInput
  none: ProjectWhereInput
}

input MarketingCampaignManyRelationFilter {
  every: MarketingCampaignWhereInput
  some: MarketingCampaignWhereInput
  none: MarketingCampaignWhereInput
}

input ProviderManyRelationFilter {
  every: ProviderWhereInput
  some: ProviderWhereInput
  none: ProviderWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input PasswordFilter {
  isSet: Boolean!
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  firstName: OrderDirection
  lastName: OrderDirection
  email: OrderDirection
  ip: OrderDirection
  isAdmin: OrderDirection
  isSubscribedToEmail: OrderDirection
  isNotChargeable: OrderDirection
  isVerified: OrderDirection
  referrer: OrderDirection
  referralCode: OrderDirection
  walletAddress: OrderDirection
  dateCreated: OrderDirection
  passwordResetIssuedAt: OrderDirection
  passwordResetRedeemedAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  firstName: String
  lastName: String
  email: String
  ip: String
  userAuth: UserAuthRelateToOneForUpdateInput
  roles: RoleRelateToManyForUpdateInput
  password: String
  isAdmin: Boolean
  isSubscribedToEmail: Boolean
  isNotChargeable: Boolean
  isVerified: Boolean
  subscription: SubscriptionRelateToOneForUpdateInput
  referrer: String
  referralCode: String
  walletAddress: String
  content: ContentRelateToManyForUpdateInput
  projects: ProjectRelateToManyForUpdateInput
  managedProjects: ProjectRelateToManyForUpdateInput
  marketingCampaigns: MarketingCampaignRelateToManyForUpdateInput
  followedProviders: ProviderRelateToManyForUpdateInput
  serviceTokens: ServiceTokenRelateToOneForUpdateInput
  providerProfile: ProviderRelateToOneForUpdateInput
  dateCreated: DateTime
  passwordResetToken: String
  passwordResetIssuedAt: DateTime
  passwordResetRedeemedAt: DateTime
}

input UserAuthRelateToOneForUpdateInput {
  create: UserAuthCreateInput
  connect: UserAuthWhereUniqueInput
  disconnect: Boolean
}

input RoleRelateToManyForUpdateInput {
  disconnect: [RoleWhereUniqueInput!]
  set: [RoleWhereUniqueInput!]
  create: [RoleCreateInput!]
  connect: [RoleWhereUniqueInput!]
}

input SubscriptionRelateToOneForUpdateInput {
  create: SubscriptionCreateInput
  connect: SubscriptionWhereUniqueInput
  disconnect: Boolean
}

input ContentRelateToManyForUpdateInput {
  disconnect: [ContentWhereUniqueInput!]
  set: [ContentWhereUniqueInput!]
  create: [ContentCreateInput!]
  connect: [ContentWhereUniqueInput!]
}

input ProjectRelateToManyForUpdateInput {
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input MarketingCampaignRelateToManyForUpdateInput {
  disconnect: [MarketingCampaignWhereUniqueInput!]
  set: [MarketingCampaignWhereUniqueInput!]
  create: [MarketingCampaignCreateInput!]
  connect: [MarketingCampaignWhereUniqueInput!]
}

input ProviderRelateToManyForUpdateInput {
  disconnect: [ProviderWhereUniqueInput!]
  set: [ProviderWhereUniqueInput!]
  create: [ProviderCreateInput!]
  connect: [ProviderWhereUniqueInput!]
}

input ServiceTokenRelateToOneForUpdateInput {
  create: ServiceTokenCreateInput
  connect: ServiceTokenWhereUniqueInput
  disconnect: Boolean
}

input ProviderRelateToOneForUpdateInput {
  create: ProviderCreateInput
  connect: ProviderWhereUniqueInput
  disconnect: Boolean
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  firstName: String
  lastName: String
  email: String
  ip: String
  userAuth: UserAuthRelateToOneForCreateInput
  roles: RoleRelateToManyForCreateInput
  password: String
  isAdmin: Boolean
  isSubscribedToEmail: Boolean
  isNotChargeable: Boolean
  isVerified: Boolean
  subscription: SubscriptionRelateToOneForCreateInput
  referrer: String
  referralCode: String
  walletAddress: String
  content: ContentRelateToManyForCreateInput
  projects: ProjectRelateToManyForCreateInput
  managedProjects: ProjectRelateToManyForCreateInput
  marketingCampaigns: MarketingCampaignRelateToManyForCreateInput
  followedProviders: ProviderRelateToManyForCreateInput
  serviceTokens: ServiceTokenRelateToOneForCreateInput
  providerProfile: ProviderRelateToOneForCreateInput
  dateCreated: DateTime
  passwordResetToken: String
  passwordResetIssuedAt: DateTime
  passwordResetRedeemedAt: DateTime
}

input UserAuthRelateToOneForCreateInput {
  create: UserAuthCreateInput
  connect: UserAuthWhereUniqueInput
}

input RoleRelateToManyForCreateInput {
  create: [RoleCreateInput!]
  connect: [RoleWhereUniqueInput!]
}

input SubscriptionRelateToOneForCreateInput {
  create: SubscriptionCreateInput
  connect: SubscriptionWhereUniqueInput
}

input ContentRelateToManyForCreateInput {
  create: [ContentCreateInput!]
  connect: [ContentWhereUniqueInput!]
}

input ProjectRelateToManyForCreateInput {
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input MarketingCampaignRelateToManyForCreateInput {
  create: [MarketingCampaignCreateInput!]
  connect: [MarketingCampaignWhereUniqueInput!]
}

input ProviderRelateToManyForCreateInput {
  create: [ProviderCreateInput!]
  connect: [ProviderWhereUniqueInput!]
}

input ServiceTokenRelateToOneForCreateInput {
  create: ServiceTokenCreateInput
  connect: ServiceTokenWhereUniqueInput
}

input ProviderRelateToOneForCreateInput {
  create: ProviderCreateInput
  connect: ProviderWhereUniqueInput
}

type Subscription {
  id: ID!
  isActive: Boolean
  product(
    where: ProductWhereInput! = {}
    orderBy: [ProductOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Product!]
  productCount(where: ProductWhereInput! = {}): Int
  user: User
  order: Order
  dateFrom: DateTime
  dateTo: DateTime
  dateAdded: DateTime
  updatedAt: DateTime
}

input SubscriptionWhereUniqueInput {
  id: ID
}

input SubscriptionWhereInput {
  AND: [SubscriptionWhereInput!]
  OR: [SubscriptionWhereInput!]
  NOT: [SubscriptionWhereInput!]
  id: IDFilter
  isActive: BooleanFilter
  product: ProductManyRelationFilter
  user: UserWhereInput
  order: OrderWhereInput
  dateFrom: DateTimeNullableFilter
  dateTo: DateTimeNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input ProductManyRelationFilter {
  every: ProductWhereInput
  some: ProductWhereInput
  none: ProductWhereInput
}

input SubscriptionOrderByInput {
  id: OrderDirection
  isActive: OrderDirection
  dateFrom: OrderDirection
  dateTo: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input SubscriptionUpdateInput {
  isActive: Boolean
  product: ProductRelateToManyForUpdateInput
  user: UserRelateToOneForUpdateInput
  order: OrderRelateToOneForUpdateInput
  dateFrom: DateTime
  dateTo: DateTime
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProductRelateToManyForUpdateInput {
  disconnect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  create: [ProductCreateInput!]
  connect: [ProductWhereUniqueInput!]
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input OrderRelateToOneForUpdateInput {
  create: OrderCreateInput
  connect: OrderWhereUniqueInput
  disconnect: Boolean
}

input SubscriptionUpdateArgs {
  where: SubscriptionWhereUniqueInput!
  data: SubscriptionUpdateInput!
}

input SubscriptionCreateInput {
  isActive: Boolean
  product: ProductRelateToManyForCreateInput
  user: UserRelateToOneForCreateInput
  order: OrderRelateToOneForCreateInput
  dateFrom: DateTime
  dateTo: DateTime
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProductRelateToManyForCreateInput {
  create: [ProductCreateInput!]
  connect: [ProductWhereUniqueInput!]
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input OrderRelateToOneForCreateInput {
  create: OrderCreateInput
  connect: OrderWhereUniqueInput
}

type Product {
  id: ID!
  name: String
  slug: String
  sku: String
  enabled: Boolean
  isForListed: Boolean
  isForUnlisted: Boolean
  isOneTime: Boolean
  isMonthly: Boolean
  label: String
  priceLabel: String
  price: Float
  discount: Float
  description: String
  offers: String
  styles: JSON
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProductWhereUniqueInput {
  id: ID
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  sku: StringFilter
  enabled: BooleanFilter
  isForListed: BooleanFilter
  isForUnlisted: BooleanFilter
  isOneTime: BooleanFilter
  isMonthly: BooleanFilter
  label: StringFilter
  priceLabel: StringFilter
  price: FloatNullableFilter
  discount: FloatNullableFilter
  description: StringFilter
  offers: StringFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input FloatNullableFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: FloatNullableFilter
}

input ProductOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  sku: OrderDirection
  enabled: OrderDirection
  isForListed: OrderDirection
  isForUnlisted: OrderDirection
  isOneTime: OrderDirection
  isMonthly: OrderDirection
  label: OrderDirection
  priceLabel: OrderDirection
  price: OrderDirection
  discount: OrderDirection
  description: OrderDirection
  offers: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input ProductUpdateInput {
  name: String
  slug: String
  sku: String
  enabled: Boolean
  isForListed: Boolean
  isForUnlisted: Boolean
  isOneTime: Boolean
  isMonthly: Boolean
  label: String
  priceLabel: String
  price: Float
  discount: Float
  description: String
  offers: String
  styles: JSON
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProductUpdateArgs {
  where: ProductWhereUniqueInput!
  data: ProductUpdateInput!
}

input ProductCreateInput {
  name: String
  slug: String
  sku: String
  enabled: Boolean
  isForListed: Boolean
  isForUnlisted: Boolean
  isOneTime: Boolean
  isMonthly: Boolean
  label: String
  priceLabel: String
  price: Float
  discount: Float
  description: String
  offers: String
  styles: JSON
  dateAdded: DateTime
  updatedAt: DateTime
}

type Role {
  id: ID!
  name: String
  slug: String
  isAdmin: Boolean
  isModerator: Boolean
  isEditor: Boolean
  isProjectOwner: Boolean
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  dateAdded: DateTime
}

input RoleWhereUniqueInput {
  id: ID
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  isAdmin: BooleanFilter
  isModerator: BooleanFilter
  isEditor: BooleanFilter
  isProjectOwner: BooleanFilter
  users: UserManyRelationFilter
  dateAdded: DateTimeNullableFilter
}

input UserManyRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input RoleOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  isAdmin: OrderDirection
  isModerator: OrderDirection
  isEditor: OrderDirection
  isProjectOwner: OrderDirection
  dateAdded: OrderDirection
}

input RoleUpdateInput {
  name: String
  slug: String
  isAdmin: Boolean
  isModerator: Boolean
  isEditor: Boolean
  isProjectOwner: Boolean
  users: UserRelateToManyForUpdateInput
  dateAdded: DateTime
}

input UserRelateToManyForUpdateInput {
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input RoleUpdateArgs {
  where: RoleWhereUniqueInput!
  data: RoleUpdateInput!
}

input RoleCreateInput {
  name: String
  slug: String
  isAdmin: Boolean
  isModerator: Boolean
  isEditor: Boolean
  isProjectOwner: Boolean
  users: UserRelateToManyForCreateInput
  dateAdded: DateTime
}

input UserRelateToManyForCreateInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

type Project {
  id: ID!
  name: String
  slug: String
  logo: ImageFieldOutput
  dateAdded: DateTime
  enabled: Boolean
  isPending: Boolean
  isAwaitingPayment: Boolean
  isListed: Boolean
  isNft: Boolean
  displayBlogPosts: Boolean
  displayTransparencyScore: Boolean
  displayCommunityVotes: Boolean
  displayCommunityComments: Boolean
  trackData: Boolean
  trackPrice: Boolean
  trackMarketCap: Boolean
  trackSocials: Boolean
  trackHolders: Boolean
  periodicWalletUpdates: Boolean
  initialized: Boolean
  markForDeletion: Boolean
  useDexScreener: Boolean
  status: String
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tagsCount(where: TagWhereInput! = {}): Int
  contractAddress: String
  pairAddress: String
  exhangeAddress: String
  burnAddress: String
  liquidityPair(
    where: LiquidityPairWhereInput! = {}
    orderBy: [LiquidityPairOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [LiquidityPair!]
  liquidityPairCount(where: LiquidityPairWhereInput! = {}): Int
  network: Network
  trackHoldersFromTokenAmount: Float
  trackHoldersFromDollarAmount: Float
  description: String
  launchDate: DateTime
  launchBlock: Int
  user(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  userCount(where: UserWhereInput! = {}): Int
  notifications(
    where: NotificationWhereInput! = {}
    orderBy: [NotificationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Notification!]
  notificationsCount(where: NotificationWhereInput! = {}): Int
  ABI: JSON
  customTrackers(
    where: CustomTrackerWhereInput! = {}
    orderBy: [CustomTrackerOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [CustomTracker!]
  customTrackersCount(where: CustomTrackerWhereInput! = {}): Int
  sellTax: Float
  buyTax: Float
  rebasePeriod: String
  apy: Float
  dailyApy: Float
  calendar: String
  website: String
  whitepaper: String
  twitter: String
  telegram: String
  discord: String
  discordServerId: String
  reddit: String
  youtube: String
  github: String
  medium: String
  kycLink: String
  auditLink: String
  customVetting: String
  tclRating: Int
  transparencyScore: Int
  paymentPlan: PaymentPlan
  auditBy(
    where: AuditWhereInput! = {}
    orderBy: [AuditOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Audit!]
  auditByCount(where: AuditWhereInput! = {}): Int
  kycBy(
    where: KycWhereInput! = {}
    orderBy: [KycOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Kyc!]
  kycByCount(where: KycWhereInput! = {}): Int
  transparencyRatings(
    where: TransparencyRatingWhereInput! = {}
    orderBy: [TransparencyRatingOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [TransparencyRating!]
  transparencyRatingsCount(where: TransparencyRatingWhereInput! = {}): Int
  transparencyHighlights: JSON
  content(
    where: ContentWhereInput! = {}
    orderBy: [ContentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Content!]
  contentCount(where: ContentWhereInput! = {}): Int
  comments(
    where: CommentWhereInput! = {}
    orderBy: [CommentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Comment!]
  commentsCount(where: CommentWhereInput! = {}): Int
  votes(
    where: VoteWhereInput! = {}
    orderBy: [VoteOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Vote!]
  votesCount(where: VoteWhereInput! = {}): Int
  events(
    where: DiscordEventWhereInput! = {}
    orderBy: [DiscordEventOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [DiscordEvent!]
  eventsCount(where: DiscordEventWhereInput! = {}): Int
  announcements(
    where: DiscordAnnouncementWhereInput! = {}
    orderBy: [DiscordAnnouncementOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [DiscordAnnouncement!]
  announcementsCount(where: DiscordAnnouncementWhereInput! = {}): Int
  discordConfig: DiscordConfig
  parentProject(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  parentProjectCount(where: ProjectWhereInput! = {}): Int
  relatedProjects(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  relatedProjectsCount(where: ProjectWhereInput! = {}): Int
}

type ImageFieldOutput {
  id: ID!
  filesize: Int!
  width: Int!
  height: Int!
  extension: ImageExtension!
  url: String!
}

enum ImageExtension {
  jpg
  png
  webp
  gif
}

input ProjectWhereUniqueInput {
  id: ID
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  dateAdded: DateTimeNullableFilter
  enabled: BooleanFilter
  isPending: BooleanFilter
  isAwaitingPayment: BooleanFilter
  isListed: BooleanFilter
  isNft: BooleanFilter
  displayBlogPosts: BooleanFilter
  displayTransparencyScore: BooleanFilter
  displayCommunityVotes: BooleanFilter
  displayCommunityComments: BooleanFilter
  trackData: BooleanFilter
  trackPrice: BooleanFilter
  trackMarketCap: BooleanFilter
  trackSocials: BooleanFilter
  trackHolders: BooleanFilter
  periodicWalletUpdates: BooleanFilter
  initialized: BooleanFilter
  markForDeletion: BooleanFilter
  useDexScreener: BooleanFilter
  status: StringNullableFilter
  tags: TagManyRelationFilter
  contractAddress: StringFilter
  pairAddress: StringFilter
  exhangeAddress: StringFilter
  burnAddress: StringFilter
  liquidityPair: LiquidityPairManyRelationFilter
  network: NetworkWhereInput
  trackHoldersFromTokenAmount: FloatNullableFilter
  trackHoldersFromDollarAmount: FloatNullableFilter
  description: StringFilter
  launchDate: DateTimeNullableFilter
  launchBlock: IntNullableFilter
  user: UserManyRelationFilter
  notifications: NotificationManyRelationFilter
  customTrackers: CustomTrackerManyRelationFilter
  sellTax: FloatNullableFilter
  buyTax: FloatNullableFilter
  rebasePeriod: StringFilter
  apy: FloatNullableFilter
  dailyApy: FloatNullableFilter
  calendar: StringFilter
  website: StringFilter
  whitepaper: StringFilter
  twitter: StringFilter
  telegram: StringFilter
  discord: StringFilter
  discordServerId: StringFilter
  reddit: StringFilter
  youtube: StringFilter
  github: StringFilter
  medium: StringFilter
  kycLink: StringFilter
  auditLink: StringFilter
  customVetting: StringFilter
  tclRating: IntNullableFilter
  transparencyScore: IntNullableFilter
  paymentPlan: PaymentPlanWhereInput
  auditBy: AuditManyRelationFilter
  kycBy: KycManyRelationFilter
  transparencyRatings: TransparencyRatingManyRelationFilter
  content: ContentManyRelationFilter
  comments: CommentManyRelationFilter
  votes: VoteManyRelationFilter
  events: DiscordEventManyRelationFilter
  announcements: DiscordAnnouncementManyRelationFilter
  discordConfig: DiscordConfigWhereInput
  parentProject: ProjectManyRelationFilter
  relatedProjects: ProjectManyRelationFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input TagManyRelationFilter {
  every: TagWhereInput
  some: TagWhereInput
  none: TagWhereInput
}

input LiquidityPairManyRelationFilter {
  every: LiquidityPairWhereInput
  some: LiquidityPairWhereInput
  none: LiquidityPairWhereInput
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input NotificationManyRelationFilter {
  every: NotificationWhereInput
  some: NotificationWhereInput
  none: NotificationWhereInput
}

input CustomTrackerManyRelationFilter {
  every: CustomTrackerWhereInput
  some: CustomTrackerWhereInput
  none: CustomTrackerWhereInput
}

input AuditManyRelationFilter {
  every: AuditWhereInput
  some: AuditWhereInput
  none: AuditWhereInput
}

input KycManyRelationFilter {
  every: KycWhereInput
  some: KycWhereInput
  none: KycWhereInput
}

input TransparencyRatingManyRelationFilter {
  every: TransparencyRatingWhereInput
  some: TransparencyRatingWhereInput
  none: TransparencyRatingWhereInput
}

input CommentManyRelationFilter {
  every: CommentWhereInput
  some: CommentWhereInput
  none: CommentWhereInput
}

input VoteManyRelationFilter {
  every: VoteWhereInput
  some: VoteWhereInput
  none: VoteWhereInput
}

input DiscordEventManyRelationFilter {
  every: DiscordEventWhereInput
  some: DiscordEventWhereInput
  none: DiscordEventWhereInput
}

input DiscordAnnouncementManyRelationFilter {
  every: DiscordAnnouncementWhereInput
  some: DiscordAnnouncementWhereInput
  none: DiscordAnnouncementWhereInput
}

input ProjectOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  dateAdded: OrderDirection
  enabled: OrderDirection
  isPending: OrderDirection
  isAwaitingPayment: OrderDirection
  isListed: OrderDirection
  isNft: OrderDirection
  displayBlogPosts: OrderDirection
  displayTransparencyScore: OrderDirection
  displayCommunityVotes: OrderDirection
  displayCommunityComments: OrderDirection
  trackData: OrderDirection
  trackPrice: OrderDirection
  trackMarketCap: OrderDirection
  trackSocials: OrderDirection
  trackHolders: OrderDirection
  periodicWalletUpdates: OrderDirection
  initialized: OrderDirection
  markForDeletion: OrderDirection
  useDexScreener: OrderDirection
  status: OrderDirection
  contractAddress: OrderDirection
  pairAddress: OrderDirection
  exhangeAddress: OrderDirection
  burnAddress: OrderDirection
  trackHoldersFromTokenAmount: OrderDirection
  trackHoldersFromDollarAmount: OrderDirection
  description: OrderDirection
  launchDate: OrderDirection
  launchBlock: OrderDirection
  sellTax: OrderDirection
  buyTax: OrderDirection
  rebasePeriod: OrderDirection
  apy: OrderDirection
  dailyApy: OrderDirection
  calendar: OrderDirection
  website: OrderDirection
  whitepaper: OrderDirection
  twitter: OrderDirection
  telegram: OrderDirection
  discord: OrderDirection
  discordServerId: OrderDirection
  reddit: OrderDirection
  youtube: OrderDirection
  github: OrderDirection
  medium: OrderDirection
  kycLink: OrderDirection
  auditLink: OrderDirection
  customVetting: OrderDirection
  tclRating: OrderDirection
  transparencyScore: OrderDirection
}

input ProjectUpdateInput {
  name: String
  slug: String
  logo: ImageFieldInput
  dateAdded: DateTime
  enabled: Boolean
  isPending: Boolean
  isAwaitingPayment: Boolean
  isListed: Boolean
  isNft: Boolean
  displayBlogPosts: Boolean
  displayTransparencyScore: Boolean
  displayCommunityVotes: Boolean
  displayCommunityComments: Boolean
  trackData: Boolean
  trackPrice: Boolean
  trackMarketCap: Boolean
  trackSocials: Boolean
  trackHolders: Boolean
  periodicWalletUpdates: Boolean
  initialized: Boolean
  markForDeletion: Boolean
  useDexScreener: Boolean
  status: String
  tags: TagRelateToManyForUpdateInput
  contractAddress: String
  pairAddress: String
  exhangeAddress: String
  burnAddress: String
  liquidityPair: LiquidityPairRelateToManyForUpdateInput
  network: NetworkRelateToOneForUpdateInput
  trackHoldersFromTokenAmount: Float
  trackHoldersFromDollarAmount: Float
  description: String
  launchDate: DateTime
  launchBlock: Int
  user: UserRelateToManyForUpdateInput
  notifications: NotificationRelateToManyForUpdateInput
  ABI: JSON
  customTrackers: CustomTrackerRelateToManyForUpdateInput
  sellTax: Float
  buyTax: Float
  rebasePeriod: String
  apy: Float
  dailyApy: Float
  calendar: String
  website: String
  whitepaper: String
  twitter: String
  telegram: String
  discord: String
  discordServerId: String
  reddit: String
  youtube: String
  github: String
  medium: String
  kycLink: String
  auditLink: String
  customVetting: String
  tclRating: Int
  transparencyScore: Int
  paymentPlan: PaymentPlanRelateToOneForUpdateInput
  auditBy: AuditRelateToManyForUpdateInput
  kycBy: KycRelateToManyForUpdateInput
  transparencyRatings: TransparencyRatingRelateToManyForUpdateInput
  transparencyHighlights: JSON
  content: ContentRelateToManyForUpdateInput
  comments: CommentRelateToManyForUpdateInput
  votes: VoteRelateToManyForUpdateInput
  events: DiscordEventRelateToManyForUpdateInput
  announcements: DiscordAnnouncementRelateToManyForUpdateInput
  discordConfig: DiscordConfigRelateToOneForUpdateInput
  parentProject: ProjectRelateToManyForUpdateInput
  relatedProjects: ProjectRelateToManyForUpdateInput
}

input ImageFieldInput {
  upload: Upload!
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input TagRelateToManyForUpdateInput {
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input LiquidityPairRelateToManyForUpdateInput {
  disconnect: [LiquidityPairWhereUniqueInput!]
  set: [LiquidityPairWhereUniqueInput!]
  create: [LiquidityPairCreateInput!]
  connect: [LiquidityPairWhereUniqueInput!]
}

input NetworkRelateToOneForUpdateInput {
  create: NetworkCreateInput
  connect: NetworkWhereUniqueInput
  disconnect: Boolean
}

input NotificationRelateToManyForUpdateInput {
  disconnect: [NotificationWhereUniqueInput!]
  set: [NotificationWhereUniqueInput!]
  create: [NotificationCreateInput!]
  connect: [NotificationWhereUniqueInput!]
}

input CustomTrackerRelateToManyForUpdateInput {
  disconnect: [CustomTrackerWhereUniqueInput!]
  set: [CustomTrackerWhereUniqueInput!]
  create: [CustomTrackerCreateInput!]
  connect: [CustomTrackerWhereUniqueInput!]
}

input PaymentPlanRelateToOneForUpdateInput {
  create: PaymentPlanCreateInput
  connect: PaymentPlanWhereUniqueInput
  disconnect: Boolean
}

input AuditRelateToManyForUpdateInput {
  disconnect: [AuditWhereUniqueInput!]
  set: [AuditWhereUniqueInput!]
  create: [AuditCreateInput!]
  connect: [AuditWhereUniqueInput!]
}

input KycRelateToManyForUpdateInput {
  disconnect: [KycWhereUniqueInput!]
  set: [KycWhereUniqueInput!]
  create: [KycCreateInput!]
  connect: [KycWhereUniqueInput!]
}

input TransparencyRatingRelateToManyForUpdateInput {
  disconnect: [TransparencyRatingWhereUniqueInput!]
  set: [TransparencyRatingWhereUniqueInput!]
  create: [TransparencyRatingCreateInput!]
  connect: [TransparencyRatingWhereUniqueInput!]
}

input CommentRelateToManyForUpdateInput {
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  create: [CommentCreateInput!]
  connect: [CommentWhereUniqueInput!]
}

input VoteRelateToManyForUpdateInput {
  disconnect: [VoteWhereUniqueInput!]
  set: [VoteWhereUniqueInput!]
  create: [VoteCreateInput!]
  connect: [VoteWhereUniqueInput!]
}

input DiscordEventRelateToManyForUpdateInput {
  disconnect: [DiscordEventWhereUniqueInput!]
  set: [DiscordEventWhereUniqueInput!]
  create: [DiscordEventCreateInput!]
  connect: [DiscordEventWhereUniqueInput!]
}

input DiscordAnnouncementRelateToManyForUpdateInput {
  disconnect: [DiscordAnnouncementWhereUniqueInput!]
  set: [DiscordAnnouncementWhereUniqueInput!]
  create: [DiscordAnnouncementCreateInput!]
  connect: [DiscordAnnouncementWhereUniqueInput!]
}

input DiscordConfigRelateToOneForUpdateInput {
  create: DiscordConfigCreateInput
  connect: DiscordConfigWhereUniqueInput
  disconnect: Boolean
}

input ProjectUpdateArgs {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateInput!
}

input ProjectCreateInput {
  name: String
  slug: String
  logo: ImageFieldInput
  dateAdded: DateTime
  enabled: Boolean
  isPending: Boolean
  isAwaitingPayment: Boolean
  isListed: Boolean
  isNft: Boolean
  displayBlogPosts: Boolean
  displayTransparencyScore: Boolean
  displayCommunityVotes: Boolean
  displayCommunityComments: Boolean
  trackData: Boolean
  trackPrice: Boolean
  trackMarketCap: Boolean
  trackSocials: Boolean
  trackHolders: Boolean
  periodicWalletUpdates: Boolean
  initialized: Boolean
  markForDeletion: Boolean
  useDexScreener: Boolean
  status: String
  tags: TagRelateToManyForCreateInput
  contractAddress: String
  pairAddress: String
  exhangeAddress: String
  burnAddress: String
  liquidityPair: LiquidityPairRelateToManyForCreateInput
  network: NetworkRelateToOneForCreateInput
  trackHoldersFromTokenAmount: Float
  trackHoldersFromDollarAmount: Float
  description: String
  launchDate: DateTime
  launchBlock: Int
  user: UserRelateToManyForCreateInput
  notifications: NotificationRelateToManyForCreateInput
  ABI: JSON
  customTrackers: CustomTrackerRelateToManyForCreateInput
  sellTax: Float
  buyTax: Float
  rebasePeriod: String
  apy: Float
  dailyApy: Float
  calendar: String
  website: String
  whitepaper: String
  twitter: String
  telegram: String
  discord: String
  discordServerId: String
  reddit: String
  youtube: String
  github: String
  medium: String
  kycLink: String
  auditLink: String
  customVetting: String
  tclRating: Int
  transparencyScore: Int
  paymentPlan: PaymentPlanRelateToOneForCreateInput
  auditBy: AuditRelateToManyForCreateInput
  kycBy: KycRelateToManyForCreateInput
  transparencyRatings: TransparencyRatingRelateToManyForCreateInput
  transparencyHighlights: JSON
  content: ContentRelateToManyForCreateInput
  comments: CommentRelateToManyForCreateInput
  votes: VoteRelateToManyForCreateInput
  events: DiscordEventRelateToManyForCreateInput
  announcements: DiscordAnnouncementRelateToManyForCreateInput
  discordConfig: DiscordConfigRelateToOneForCreateInput
  parentProject: ProjectRelateToManyForCreateInput
  relatedProjects: ProjectRelateToManyForCreateInput
}

input TagRelateToManyForCreateInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input LiquidityPairRelateToManyForCreateInput {
  create: [LiquidityPairCreateInput!]
  connect: [LiquidityPairWhereUniqueInput!]
}

input NetworkRelateToOneForCreateInput {
  create: NetworkCreateInput
  connect: NetworkWhereUniqueInput
}

input NotificationRelateToManyForCreateInput {
  create: [NotificationCreateInput!]
  connect: [NotificationWhereUniqueInput!]
}

input CustomTrackerRelateToManyForCreateInput {
  create: [CustomTrackerCreateInput!]
  connect: [CustomTrackerWhereUniqueInput!]
}

input PaymentPlanRelateToOneForCreateInput {
  create: PaymentPlanCreateInput
  connect: PaymentPlanWhereUniqueInput
}

input AuditRelateToManyForCreateInput {
  create: [AuditCreateInput!]
  connect: [AuditWhereUniqueInput!]
}

input KycRelateToManyForCreateInput {
  create: [KycCreateInput!]
  connect: [KycWhereUniqueInput!]
}

input TransparencyRatingRelateToManyForCreateInput {
  create: [TransparencyRatingCreateInput!]
  connect: [TransparencyRatingWhereUniqueInput!]
}

input CommentRelateToManyForCreateInput {
  create: [CommentCreateInput!]
  connect: [CommentWhereUniqueInput!]
}

input VoteRelateToManyForCreateInput {
  create: [VoteCreateInput!]
  connect: [VoteWhereUniqueInput!]
}

input DiscordEventRelateToManyForCreateInput {
  create: [DiscordEventCreateInput!]
  connect: [DiscordEventWhereUniqueInput!]
}

input DiscordAnnouncementRelateToManyForCreateInput {
  create: [DiscordAnnouncementCreateInput!]
  connect: [DiscordAnnouncementWhereUniqueInput!]
}

input DiscordConfigRelateToOneForCreateInput {
  create: DiscordConfigCreateInput
  connect: DiscordConfigWhereUniqueInput
}

type PaymentPlan {
  id: ID!
  name: String
  slug: String
  tooltip: String
  description: String
  enabled: Boolean
  price: Float
  discount: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input PaymentPlanWhereUniqueInput {
  id: ID
}

input PaymentPlanWhereInput {
  AND: [PaymentPlanWhereInput!]
  OR: [PaymentPlanWhereInput!]
  NOT: [PaymentPlanWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  tooltip: StringFilter
  description: StringFilter
  enabled: BooleanFilter
  price: FloatNullableFilter
  discount: FloatNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input PaymentPlanOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  tooltip: OrderDirection
  description: OrderDirection
  enabled: OrderDirection
  price: OrderDirection
  discount: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input PaymentPlanUpdateInput {
  name: String
  slug: String
  tooltip: String
  description: String
  enabled: Boolean
  price: Float
  discount: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input PaymentPlanUpdateArgs {
  where: PaymentPlanWhereUniqueInput!
  data: PaymentPlanUpdateInput!
}

input PaymentPlanCreateInput {
  name: String
  slug: String
  tooltip: String
  description: String
  enabled: Boolean
  price: Float
  discount: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

type Coupon {
  id: ID!
  name: String
  code: String
  enabled: Boolean
  discountPercentage: Int
  timesPerUser: Int
  validFrom: DateTime
  validTill: DateTime
  usedBy: JSON
  acceptFromReferrers(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  acceptFromReferrersCount(where: UserWhereInput! = {}): Int
  acceptFromNetworks(
    where: NetworkWhereInput! = {}
    orderBy: [NetworkOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Network!]
  acceptFromNetworksCount(where: NetworkWhereInput! = {}): Int
  cart(
    where: CartWhereInput! = {}
    orderBy: [CartOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Cart!]
  cartCount(where: CartWhereInput! = {}): Int
  order(
    where: OrderWhereInput! = {}
    orderBy: [OrderOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Order!]
  orderCount(where: OrderWhereInput! = {}): Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input CouponWhereUniqueInput {
  id: ID
}

input CouponWhereInput {
  AND: [CouponWhereInput!]
  OR: [CouponWhereInput!]
  NOT: [CouponWhereInput!]
  id: IDFilter
  name: StringFilter
  code: StringFilter
  enabled: BooleanFilter
  discountPercentage: IntNullableFilter
  timesPerUser: IntNullableFilter
  validFrom: DateTimeNullableFilter
  validTill: DateTimeNullableFilter
  acceptFromReferrers: UserManyRelationFilter
  acceptFromNetworks: NetworkManyRelationFilter
  cart: CartManyRelationFilter
  order: OrderManyRelationFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input NetworkManyRelationFilter {
  every: NetworkWhereInput
  some: NetworkWhereInput
  none: NetworkWhereInput
}

input CartManyRelationFilter {
  every: CartWhereInput
  some: CartWhereInput
  none: CartWhereInput
}

input OrderManyRelationFilter {
  every: OrderWhereInput
  some: OrderWhereInput
  none: OrderWhereInput
}

input CouponOrderByInput {
  id: OrderDirection
  name: OrderDirection
  code: OrderDirection
  enabled: OrderDirection
  discountPercentage: OrderDirection
  timesPerUser: OrderDirection
  validFrom: OrderDirection
  validTill: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input CouponUpdateInput {
  name: String
  code: String
  enabled: Boolean
  discountPercentage: Int
  timesPerUser: Int
  validFrom: DateTime
  validTill: DateTime
  usedBy: JSON
  acceptFromReferrers: UserRelateToManyForUpdateInput
  acceptFromNetworks: NetworkRelateToManyForUpdateInput
  cart: CartRelateToManyForUpdateInput
  order: OrderRelateToManyForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input NetworkRelateToManyForUpdateInput {
  disconnect: [NetworkWhereUniqueInput!]
  set: [NetworkWhereUniqueInput!]
  create: [NetworkCreateInput!]
  connect: [NetworkWhereUniqueInput!]
}

input CartRelateToManyForUpdateInput {
  disconnect: [CartWhereUniqueInput!]
  set: [CartWhereUniqueInput!]
  create: [CartCreateInput!]
  connect: [CartWhereUniqueInput!]
}

input OrderRelateToManyForUpdateInput {
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  create: [OrderCreateInput!]
  connect: [OrderWhereUniqueInput!]
}

input CouponUpdateArgs {
  where: CouponWhereUniqueInput!
  data: CouponUpdateInput!
}

input CouponCreateInput {
  name: String
  code: String
  enabled: Boolean
  discountPercentage: Int
  timesPerUser: Int
  validFrom: DateTime
  validTill: DateTime
  usedBy: JSON
  acceptFromReferrers: UserRelateToManyForCreateInput
  acceptFromNetworks: NetworkRelateToManyForCreateInput
  cart: CartRelateToManyForCreateInput
  order: OrderRelateToManyForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input NetworkRelateToManyForCreateInput {
  create: [NetworkCreateInput!]
  connect: [NetworkWhereUniqueInput!]
}

input CartRelateToManyForCreateInput {
  create: [CartCreateInput!]
  connect: [CartWhereUniqueInput!]
}

input OrderRelateToManyForCreateInput {
  create: [OrderCreateInput!]
  connect: [OrderWhereUniqueInput!]
}

type Audit {
  id: ID!
  project: Project
  auditor: Auditor
  url: String
}

input AuditWhereUniqueInput {
  id: ID
}

input AuditWhereInput {
  AND: [AuditWhereInput!]
  OR: [AuditWhereInput!]
  NOT: [AuditWhereInput!]
  id: IDFilter
  project: ProjectWhereInput
  auditor: AuditorWhereInput
  url: StringFilter
}

input AuditOrderByInput {
  id: OrderDirection
  url: OrderDirection
}

input AuditUpdateInput {
  project: ProjectRelateToOneForUpdateInput
  auditor: AuditorRelateToOneForUpdateInput
  url: String
}

input ProjectRelateToOneForUpdateInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
  disconnect: Boolean
}

input AuditorRelateToOneForUpdateInput {
  create: AuditorCreateInput
  connect: AuditorWhereUniqueInput
  disconnect: Boolean
}

input AuditUpdateArgs {
  where: AuditWhereUniqueInput!
  data: AuditUpdateInput!
}

input AuditCreateInput {
  project: ProjectRelateToOneForCreateInput
  auditor: AuditorRelateToOneForCreateInput
  url: String
}

input ProjectRelateToOneForCreateInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
}

input AuditorRelateToOneForCreateInput {
  create: AuditorCreateInput
  connect: AuditorWhereUniqueInput
}

type Kyc {
  id: ID!
  project: Project
  kycGroup: KycGroup
  url: String
}

input KycWhereUniqueInput {
  id: ID
}

input KycWhereInput {
  AND: [KycWhereInput!]
  OR: [KycWhereInput!]
  NOT: [KycWhereInput!]
  id: IDFilter
  project: ProjectWhereInput
  kycGroup: KycGroupWhereInput
  url: StringFilter
}

input KycOrderByInput {
  id: OrderDirection
  url: OrderDirection
}

input KycUpdateInput {
  project: ProjectRelateToOneForUpdateInput
  kycGroup: KycGroupRelateToOneForUpdateInput
  url: String
}

input KycGroupRelateToOneForUpdateInput {
  create: KycGroupCreateInput
  connect: KycGroupWhereUniqueInput
  disconnect: Boolean
}

input KycUpdateArgs {
  where: KycWhereUniqueInput!
  data: KycUpdateInput!
}

input KycCreateInput {
  project: ProjectRelateToOneForCreateInput
  kycGroup: KycGroupRelateToOneForCreateInput
  url: String
}

input KycGroupRelateToOneForCreateInput {
  create: KycGroupCreateInput
  connect: KycGroupWhereUniqueInput
}

type Notification {
  id: ID!
  title: String
  enabled: Boolean
  content: String
  type: String
  project: Project
  dateAdded: DateTime
}

input NotificationWhereUniqueInput {
  id: ID
}

input NotificationWhereInput {
  AND: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  NOT: [NotificationWhereInput!]
  id: IDFilter
  title: StringFilter
  enabled: BooleanFilter
  content: StringFilter
  type: StringNullableFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
}

input NotificationOrderByInput {
  id: OrderDirection
  title: OrderDirection
  enabled: OrderDirection
  content: OrderDirection
  type: OrderDirection
  dateAdded: OrderDirection
}

input NotificationUpdateInput {
  title: String
  enabled: Boolean
  content: String
  type: String
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
}

input NotificationUpdateArgs {
  where: NotificationWhereUniqueInput!
  data: NotificationUpdateInput!
}

input NotificationCreateInput {
  title: String
  enabled: Boolean
  content: String
  type: String
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
}

type MarketStat {
  id: ID!
  price: Float
  marketCap: Float
  totalSupply: Float
  liquidity: Float
  pairPrice: Float
  burnedTokens: Float
  txns: JSON
  volume: JSON
  fdv: Float
  holders: Float
  avgHoldings: Float
  newHolders: Float
  leavingHolders: Float
  recurringHolders: Float
  annotation: JSON
  customTrackers: JSON
  project: Project
  dateAdded: DateTime
}

input MarketStatWhereUniqueInput {
  id: ID
}

input MarketStatWhereInput {
  AND: [MarketStatWhereInput!]
  OR: [MarketStatWhereInput!]
  NOT: [MarketStatWhereInput!]
  id: IDFilter
  price: FloatNullableFilter
  marketCap: FloatNullableFilter
  totalSupply: FloatNullableFilter
  liquidity: FloatNullableFilter
  pairPrice: FloatNullableFilter
  burnedTokens: FloatNullableFilter
  fdv: FloatNullableFilter
  holders: FloatNullableFilter
  avgHoldings: FloatNullableFilter
  newHolders: FloatNullableFilter
  leavingHolders: FloatNullableFilter
  recurringHolders: FloatNullableFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
}

input MarketStatOrderByInput {
  id: OrderDirection
  price: OrderDirection
  marketCap: OrderDirection
  totalSupply: OrderDirection
  liquidity: OrderDirection
  pairPrice: OrderDirection
  burnedTokens: OrderDirection
  fdv: OrderDirection
  holders: OrderDirection
  avgHoldings: OrderDirection
  newHolders: OrderDirection
  leavingHolders: OrderDirection
  recurringHolders: OrderDirection
  dateAdded: OrderDirection
}

input MarketStatUpdateInput {
  price: Float
  marketCap: Float
  totalSupply: Float
  liquidity: Float
  pairPrice: Float
  burnedTokens: Float
  txns: JSON
  volume: JSON
  fdv: Float
  holders: Float
  avgHoldings: Float
  newHolders: Float
  leavingHolders: Float
  recurringHolders: Float
  annotation: JSON
  customTrackers: JSON
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
}

input MarketStatUpdateArgs {
  where: MarketStatWhereUniqueInput!
  data: MarketStatUpdateInput!
}

input MarketStatCreateInput {
  price: Float
  marketCap: Float
  totalSupply: Float
  liquidity: Float
  pairPrice: Float
  burnedTokens: Float
  txns: JSON
  volume: JSON
  fdv: Float
  holders: Float
  avgHoldings: Float
  newHolders: Float
  leavingHolders: Float
  recurringHolders: Float
  annotation: JSON
  customTrackers: JSON
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
}

type SocialStat {
  id: ID!
  twitter: Float
  telegram: Float
  discord: Float
  annotation: JSON
  project: Project
  dateAdded: DateTime
}

input SocialStatWhereUniqueInput {
  id: ID
}

input SocialStatWhereInput {
  AND: [SocialStatWhereInput!]
  OR: [SocialStatWhereInput!]
  NOT: [SocialStatWhereInput!]
  id: IDFilter
  twitter: FloatNullableFilter
  telegram: FloatNullableFilter
  discord: FloatNullableFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
}

input SocialStatOrderByInput {
  id: OrderDirection
  twitter: OrderDirection
  telegram: OrderDirection
  discord: OrderDirection
  dateAdded: OrderDirection
}

input SocialStatUpdateInput {
  twitter: Float
  telegram: Float
  discord: Float
  annotation: JSON
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
}

input SocialStatUpdateArgs {
  where: SocialStatWhereUniqueInput!
  data: SocialStatUpdateInput!
}

input SocialStatCreateInput {
  twitter: Float
  telegram: Float
  discord: Float
  annotation: JSON
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
}

type CustomTracker {
  id: ID!
  label: String
  description: String
  address: String
  pairAddress: String
  getBalanceOf: String
  decimals: Float
  enabled: Boolean
  useDexScreener: Boolean
  isCurrency: Boolean
  applyProjectNativeTokenPrice: Boolean
  applyProjectTokenPrice: Boolean
  method: String
  network: Network
  project(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  projectCount(where: ProjectWhereInput! = {}): Int
  dateAdded: DateTime
}

input CustomTrackerWhereUniqueInput {
  id: ID
}

input CustomTrackerWhereInput {
  AND: [CustomTrackerWhereInput!]
  OR: [CustomTrackerWhereInput!]
  NOT: [CustomTrackerWhereInput!]
  id: IDFilter
  label: StringFilter
  description: StringFilter
  address: StringFilter
  pairAddress: StringFilter
  getBalanceOf: StringFilter
  decimals: FloatNullableFilter
  enabled: BooleanFilter
  useDexScreener: BooleanFilter
  isCurrency: BooleanFilter
  applyProjectNativeTokenPrice: BooleanFilter
  applyProjectTokenPrice: BooleanFilter
  method: StringNullableFilter
  network: NetworkWhereInput
  project: ProjectManyRelationFilter
  dateAdded: DateTimeNullableFilter
}

input CustomTrackerOrderByInput {
  id: OrderDirection
  label: OrderDirection
  description: OrderDirection
  address: OrderDirection
  pairAddress: OrderDirection
  getBalanceOf: OrderDirection
  decimals: OrderDirection
  enabled: OrderDirection
  useDexScreener: OrderDirection
  isCurrency: OrderDirection
  applyProjectNativeTokenPrice: OrderDirection
  applyProjectTokenPrice: OrderDirection
  method: OrderDirection
  dateAdded: OrderDirection
}

input CustomTrackerUpdateInput {
  label: String
  description: String
  address: String
  pairAddress: String
  getBalanceOf: String
  decimals: Float
  enabled: Boolean
  useDexScreener: Boolean
  isCurrency: Boolean
  applyProjectNativeTokenPrice: Boolean
  applyProjectTokenPrice: Boolean
  method: String
  network: NetworkRelateToOneForUpdateInput
  project: ProjectRelateToManyForUpdateInput
  dateAdded: DateTime
}

input CustomTrackerUpdateArgs {
  where: CustomTrackerWhereUniqueInput!
  data: CustomTrackerUpdateInput!
}

input CustomTrackerCreateInput {
  label: String
  description: String
  address: String
  pairAddress: String
  getBalanceOf: String
  decimals: Float
  enabled: Boolean
  useDexScreener: Boolean
  isCurrency: Boolean
  applyProjectNativeTokenPrice: Boolean
  applyProjectTokenPrice: Boolean
  method: String
  network: NetworkRelateToOneForCreateInput
  project: ProjectRelateToManyForCreateInput
  dateAdded: DateTime
}

type LiquidityPair {
  id: ID!
  name: String
  address: String
  tokenAddress: String
  order: Int
  isPrimary: Boolean
  useDexScreener: Boolean
  stablePair: StableLiquidityPair
  network: Network
  project(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  projectCount(where: ProjectWhereInput! = {}): Int
  exchange: Exchange
  customExchangeAddress: String
  dateAdded: DateTime
}

input LiquidityPairWhereUniqueInput {
  id: ID
}

input LiquidityPairWhereInput {
  AND: [LiquidityPairWhereInput!]
  OR: [LiquidityPairWhereInput!]
  NOT: [LiquidityPairWhereInput!]
  id: IDFilter
  name: StringFilter
  address: StringFilter
  tokenAddress: StringFilter
  order: IntNullableFilter
  isPrimary: BooleanFilter
  useDexScreener: BooleanFilter
  stablePair: StableLiquidityPairWhereInput
  network: NetworkWhereInput
  project: ProjectManyRelationFilter
  exchange: ExchangeWhereInput
  customExchangeAddress: StringFilter
  dateAdded: DateTimeNullableFilter
}

input LiquidityPairOrderByInput {
  id: OrderDirection
  name: OrderDirection
  address: OrderDirection
  tokenAddress: OrderDirection
  order: OrderDirection
  isPrimary: OrderDirection
  useDexScreener: OrderDirection
  customExchangeAddress: OrderDirection
  dateAdded: OrderDirection
}

input LiquidityPairUpdateInput {
  name: String
  address: String
  tokenAddress: String
  order: Int
  isPrimary: Boolean
  useDexScreener: Boolean
  stablePair: StableLiquidityPairRelateToOneForUpdateInput
  network: NetworkRelateToOneForUpdateInput
  project: ProjectRelateToManyForUpdateInput
  exchange: ExchangeRelateToOneForUpdateInput
  customExchangeAddress: String
  dateAdded: DateTime
}

input StableLiquidityPairRelateToOneForUpdateInput {
  create: StableLiquidityPairCreateInput
  connect: StableLiquidityPairWhereUniqueInput
  disconnect: Boolean
}

input ExchangeRelateToOneForUpdateInput {
  create: ExchangeCreateInput
  connect: ExchangeWhereUniqueInput
  disconnect: Boolean
}

input LiquidityPairUpdateArgs {
  where: LiquidityPairWhereUniqueInput!
  data: LiquidityPairUpdateInput!
}

input LiquidityPairCreateInput {
  name: String
  address: String
  tokenAddress: String
  order: Int
  isPrimary: Boolean
  useDexScreener: Boolean
  stablePair: StableLiquidityPairRelateToOneForCreateInput
  network: NetworkRelateToOneForCreateInput
  project: ProjectRelateToManyForCreateInput
  exchange: ExchangeRelateToOneForCreateInput
  customExchangeAddress: String
  dateAdded: DateTime
}

input StableLiquidityPairRelateToOneForCreateInput {
  create: StableLiquidityPairCreateInput
  connect: StableLiquidityPairWhereUniqueInput
}

input ExchangeRelateToOneForCreateInput {
  create: ExchangeCreateInput
  connect: ExchangeWhereUniqueInput
}

type Tag {
  id: ID!
  name: String
  type: String
  projects(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  providers(
    where: ProviderWhereInput! = {}
    orderBy: [ProviderOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Provider!]
  providersCount(where: ProviderWhereInput! = {}): Int
  dateAdded: DateTime
}

input TagWhereUniqueInput {
  id: ID
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
  id: IDFilter
  name: StringFilter
  type: StringNullableFilter
  projects: ProjectManyRelationFilter
  providers: ProviderManyRelationFilter
  dateAdded: DateTimeNullableFilter
}

input TagOrderByInput {
  id: OrderDirection
  name: OrderDirection
  type: OrderDirection
  dateAdded: OrderDirection
}

input TagUpdateInput {
  name: String
  type: String
  projects: ProjectRelateToManyForUpdateInput
  providers: ProviderRelateToManyForUpdateInput
  dateAdded: DateTime
}

input TagUpdateArgs {
  where: TagWhereUniqueInput!
  data: TagUpdateInput!
}

input TagCreateInput {
  name: String
  type: String
  projects: ProjectRelateToManyForCreateInput
  providers: ProviderRelateToManyForCreateInput
  dateAdded: DateTime
}

type Exchange {
  id: ID!
  name: String
  logo: ImageFieldOutput
  url: String
  tradeUrl: String
  dateAdded: DateTime
}

input ExchangeWhereUniqueInput {
  id: ID
}

input ExchangeWhereInput {
  AND: [ExchangeWhereInput!]
  OR: [ExchangeWhereInput!]
  NOT: [ExchangeWhereInput!]
  id: IDFilter
  name: StringFilter
  url: StringFilter
  tradeUrl: StringFilter
  dateAdded: DateTimeNullableFilter
}

input ExchangeOrderByInput {
  id: OrderDirection
  name: OrderDirection
  url: OrderDirection
  tradeUrl: OrderDirection
  dateAdded: OrderDirection
}

input ExchangeUpdateInput {
  name: String
  logo: ImageFieldInput
  url: String
  tradeUrl: String
  dateAdded: DateTime
}

input ExchangeUpdateArgs {
  where: ExchangeWhereUniqueInput!
  data: ExchangeUpdateInput!
}

input ExchangeCreateInput {
  name: String
  logo: ImageFieldInput
  url: String
  tradeUrl: String
  dateAdded: DateTime
}

type Token {
  id: ID!
  name: String
  address: String
  order: Int
  ABI: JSON
  network: Network
  dateAdded: DateTime
}

input TokenWhereUniqueInput {
  id: ID
}

input TokenWhereInput {
  AND: [TokenWhereInput!]
  OR: [TokenWhereInput!]
  NOT: [TokenWhereInput!]
  id: IDFilter
  name: StringFilter
  address: StringFilter
  order: IntNullableFilter
  network: NetworkWhereInput
  dateAdded: DateTimeNullableFilter
}

input TokenOrderByInput {
  id: OrderDirection
  name: OrderDirection
  address: OrderDirection
  order: OrderDirection
  dateAdded: OrderDirection
}

input TokenUpdateInput {
  name: String
  address: String
  order: Int
  ABI: JSON
  network: NetworkRelateToOneForUpdateInput
  dateAdded: DateTime
}

input TokenUpdateArgs {
  where: TokenWhereUniqueInput!
  data: TokenUpdateInput!
}

input TokenCreateInput {
  name: String
  address: String
  order: Int
  ABI: JSON
  network: NetworkRelateToOneForCreateInput
  dateAdded: DateTime
}

type Network {
  id: ID!
  name: String
  slug: String
  logo: ImageFieldOutput
  url: String
  scanner: String
  tokenScanner: String
  txScanner: String
  dateAdded: DateTime
}

input NetworkWhereUniqueInput {
  id: ID
}

input NetworkWhereInput {
  AND: [NetworkWhereInput!]
  OR: [NetworkWhereInput!]
  NOT: [NetworkWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  url: StringFilter
  scanner: StringFilter
  tokenScanner: StringFilter
  txScanner: StringFilter
  dateAdded: DateTimeNullableFilter
}

input NetworkOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  url: OrderDirection
  scanner: OrderDirection
  tokenScanner: OrderDirection
  txScanner: OrderDirection
  dateAdded: OrderDirection
}

input NetworkUpdateInput {
  name: String
  slug: String
  logo: ImageFieldInput
  url: String
  scanner: String
  tokenScanner: String
  txScanner: String
  dateAdded: DateTime
}

input NetworkUpdateArgs {
  where: NetworkWhereUniqueInput!
  data: NetworkUpdateInput!
}

input NetworkCreateInput {
  name: String
  slug: String
  logo: ImageFieldInput
  url: String
  scanner: String
  tokenScanner: String
  txScanner: String
  dateAdded: DateTime
}

type StableLiquidityPair {
  id: ID!
  name: String
  address: String
  pairToken(
    where: TokenWhereInput! = {}
    orderBy: [TokenOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Token!]
  pairTokenCount(where: TokenWhereInput! = {}): Int
  network: Network
  dateAdded: DateTime
}

input StableLiquidityPairWhereUniqueInput {
  id: ID
}

input StableLiquidityPairWhereInput {
  AND: [StableLiquidityPairWhereInput!]
  OR: [StableLiquidityPairWhereInput!]
  NOT: [StableLiquidityPairWhereInput!]
  id: IDFilter
  name: StringFilter
  address: StringFilter
  pairToken: TokenManyRelationFilter
  network: NetworkWhereInput
  dateAdded: DateTimeNullableFilter
}

input TokenManyRelationFilter {
  every: TokenWhereInput
  some: TokenWhereInput
  none: TokenWhereInput
}

input StableLiquidityPairOrderByInput {
  id: OrderDirection
  name: OrderDirection
  address: OrderDirection
  dateAdded: OrderDirection
}

input StableLiquidityPairUpdateInput {
  name: String
  address: String
  pairToken: TokenRelateToManyForUpdateInput
  network: NetworkRelateToOneForUpdateInput
  dateAdded: DateTime
}

input TokenRelateToManyForUpdateInput {
  disconnect: [TokenWhereUniqueInput!]
  set: [TokenWhereUniqueInput!]
  create: [TokenCreateInput!]
  connect: [TokenWhereUniqueInput!]
}

input StableLiquidityPairUpdateArgs {
  where: StableLiquidityPairWhereUniqueInput!
  data: StableLiquidityPairUpdateInput!
}

input StableLiquidityPairCreateInput {
  name: String
  address: String
  pairToken: TokenRelateToManyForCreateInput
  network: NetworkRelateToOneForCreateInput
  dateAdded: DateTime
}

input TokenRelateToManyForCreateInput {
  create: [TokenCreateInput!]
  connect: [TokenWhereUniqueInput!]
}

type DiscordConfig {
  id: ID!
  guildName: String
  guildId: String
  announcementsChannelId: String
  announcementsChannelName: String
  generalChannelId: String
  generalChannelName: String
  project: Project
  dateAdded: DateTime
  updatedAt: DateTime
}

input DiscordConfigWhereUniqueInput {
  id: ID
}

input DiscordConfigWhereInput {
  AND: [DiscordConfigWhereInput!]
  OR: [DiscordConfigWhereInput!]
  NOT: [DiscordConfigWhereInput!]
  id: IDFilter
  guildName: StringFilter
  guildId: StringFilter
  announcementsChannelId: StringFilter
  announcementsChannelName: StringFilter
  generalChannelId: StringFilter
  generalChannelName: StringFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input DiscordConfigOrderByInput {
  id: OrderDirection
  guildName: OrderDirection
  guildId: OrderDirection
  announcementsChannelId: OrderDirection
  announcementsChannelName: OrderDirection
  generalChannelId: OrderDirection
  generalChannelName: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input DiscordConfigUpdateInput {
  guildName: String
  guildId: String
  announcementsChannelId: String
  announcementsChannelName: String
  generalChannelId: String
  generalChannelName: String
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input DiscordConfigUpdateArgs {
  where: DiscordConfigWhereUniqueInput!
  data: DiscordConfigUpdateInput!
}

input DiscordConfigCreateInput {
  guildName: String
  guildId: String
  announcementsChannelId: String
  announcementsChannelName: String
  generalChannelId: String
  generalChannelName: String
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type DiscordEvent {
  id: ID!
  eventId: String
  guildId: String
  channelId: String
  guildName: String
  channelName: String
  name: String
  description: String
  inviteUrl: String
  scheduledStartTimestamp: DateTime
  scheduledEndTimestamp: DateTime
  location: String
  userCount: Int
  image: String
  project: Project
  dateAdded: DateTime
  updatedAt: DateTime
}

input DiscordEventWhereUniqueInput {
  id: ID
}

input DiscordEventWhereInput {
  AND: [DiscordEventWhereInput!]
  OR: [DiscordEventWhereInput!]
  NOT: [DiscordEventWhereInput!]
  id: IDFilter
  eventId: StringFilter
  guildId: StringFilter
  channelId: StringFilter
  guildName: StringFilter
  channelName: StringFilter
  name: StringFilter
  description: StringFilter
  inviteUrl: StringFilter
  scheduledStartTimestamp: DateTimeNullableFilter
  scheduledEndTimestamp: DateTimeNullableFilter
  location: StringFilter
  userCount: IntNullableFilter
  image: StringFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input DiscordEventOrderByInput {
  id: OrderDirection
  eventId: OrderDirection
  guildId: OrderDirection
  channelId: OrderDirection
  guildName: OrderDirection
  channelName: OrderDirection
  name: OrderDirection
  description: OrderDirection
  inviteUrl: OrderDirection
  scheduledStartTimestamp: OrderDirection
  scheduledEndTimestamp: OrderDirection
  location: OrderDirection
  userCount: OrderDirection
  image: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input DiscordEventUpdateInput {
  eventId: String
  guildId: String
  channelId: String
  guildName: String
  channelName: String
  name: String
  description: String
  inviteUrl: String
  scheduledStartTimestamp: DateTime
  scheduledEndTimestamp: DateTime
  location: String
  userCount: Int
  image: String
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input DiscordEventUpdateArgs {
  where: DiscordEventWhereUniqueInput!
  data: DiscordEventUpdateInput!
}

input DiscordEventCreateInput {
  eventId: String
  guildId: String
  channelId: String
  guildName: String
  channelName: String
  name: String
  description: String
  inviteUrl: String
  scheduledStartTimestamp: DateTime
  scheduledEndTimestamp: DateTime
  location: String
  userCount: Int
  image: String
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type DiscordAnnouncement {
  id: ID!
  messageId: String
  guildId: String
  channelId: String
  title: String
  content: JSON
  messageUrl: String
  project: Project
  dateAdded: DateTime
  updatedAt: DateTime
}

input DiscordAnnouncementWhereUniqueInput {
  id: ID
}

input DiscordAnnouncementWhereInput {
  AND: [DiscordAnnouncementWhereInput!]
  OR: [DiscordAnnouncementWhereInput!]
  NOT: [DiscordAnnouncementWhereInput!]
  id: IDFilter
  messageId: StringFilter
  guildId: StringFilter
  channelId: StringFilter
  title: StringFilter
  messageUrl: StringFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input DiscordAnnouncementOrderByInput {
  id: OrderDirection
  messageId: OrderDirection
  guildId: OrderDirection
  channelId: OrderDirection
  title: OrderDirection
  messageUrl: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input DiscordAnnouncementUpdateInput {
  messageId: String
  guildId: String
  channelId: String
  title: String
  content: JSON
  messageUrl: String
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input DiscordAnnouncementUpdateArgs {
  where: DiscordAnnouncementWhereUniqueInput!
  data: DiscordAnnouncementUpdateInput!
}

input DiscordAnnouncementCreateInput {
  messageId: String
  guildId: String
  channelId: String
  title: String
  content: JSON
  messageUrl: String
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type DiscordBot {
  id: ID!
  name: String
  enabled: Boolean
  presence: String
  botId: String
  apiKey: String
  tracking: String
  customTracking: String
  project: Project
  dateAdded: DateTime
}

input DiscordBotWhereUniqueInput {
  id: ID
}

input DiscordBotWhereInput {
  AND: [DiscordBotWhereInput!]
  OR: [DiscordBotWhereInput!]
  NOT: [DiscordBotWhereInput!]
  id: IDFilter
  name: StringFilter
  enabled: BooleanFilter
  presence: StringFilter
  botId: StringFilter
  apiKey: StringFilter
  tracking: StringNullableFilter
  customTracking: StringFilter
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
}

input DiscordBotOrderByInput {
  id: OrderDirection
  name: OrderDirection
  enabled: OrderDirection
  presence: OrderDirection
  botId: OrderDirection
  apiKey: OrderDirection
  tracking: OrderDirection
  customTracking: OrderDirection
  dateAdded: OrderDirection
}

input DiscordBotUpdateInput {
  name: String
  enabled: Boolean
  presence: String
  botId: String
  apiKey: String
  tracking: String
  customTracking: String
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
}

input DiscordBotUpdateArgs {
  where: DiscordBotWhereUniqueInput!
  data: DiscordBotUpdateInput!
}

input DiscordBotCreateInput {
  name: String
  enabled: Boolean
  presence: String
  botId: String
  apiKey: String
  tracking: String
  customTracking: String
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
}

type Content {
  id: ID!
  title: String
  slug: String
  image: ImageFieldOutput
  contentType: ContentType
  enabled: Boolean
  summary: String
  richContent: JSON
  content: Content_content_Document
  blockName: ContentBlock
  user: User
  project: Project
  views: Int
  likes(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  likesCount(where: UserWhereInput! = {}): Int
  dateAdded: DateTime
}

type Content_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input ContentWhereUniqueInput {
  id: ID
}

input ContentWhereInput {
  AND: [ContentWhereInput!]
  OR: [ContentWhereInput!]
  NOT: [ContentWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  contentType: ContentTypeWhereInput
  enabled: BooleanFilter
  summary: StringFilter
  blockName: ContentBlockWhereInput
  user: UserWhereInput
  project: ProjectWhereInput
  views: IntNullableFilter
  likes: UserManyRelationFilter
  dateAdded: DateTimeNullableFilter
}

input ContentOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  enabled: OrderDirection
  summary: OrderDirection
  views: OrderDirection
  dateAdded: OrderDirection
}

input ContentUpdateInput {
  title: String
  slug: String
  image: ImageFieldInput
  contentType: ContentTypeRelateToOneForUpdateInput
  enabled: Boolean
  summary: String
  richContent: JSON
  content: JSON
  blockName: ContentBlockRelateToOneForUpdateInput
  user: UserRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  views: Int
  likes: UserRelateToManyForUpdateInput
  dateAdded: DateTime
}

input ContentTypeRelateToOneForUpdateInput {
  create: ContentTypeCreateInput
  connect: ContentTypeWhereUniqueInput
  disconnect: Boolean
}

input ContentBlockRelateToOneForUpdateInput {
  create: ContentBlockCreateInput
  connect: ContentBlockWhereUniqueInput
  disconnect: Boolean
}

input ContentUpdateArgs {
  where: ContentWhereUniqueInput!
  data: ContentUpdateInput!
}

input ContentCreateInput {
  title: String
  slug: String
  image: ImageFieldInput
  contentType: ContentTypeRelateToOneForCreateInput
  enabled: Boolean
  summary: String
  richContent: JSON
  content: JSON
  blockName: ContentBlockRelateToOneForCreateInput
  user: UserRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  views: Int
  likes: UserRelateToManyForCreateInput
  dateAdded: DateTime
}

input ContentTypeRelateToOneForCreateInput {
  create: ContentTypeCreateInput
  connect: ContentTypeWhereUniqueInput
}

input ContentBlockRelateToOneForCreateInput {
  create: ContentBlockCreateInput
  connect: ContentBlockWhereUniqueInput
}

type Comment {
  id: ID!
  content: JSON
  sentiment: Int
  likes(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  likesCount(where: UserWhereInput! = {}): Int
  reports(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  reportsCount(where: UserWhereInput! = {}): Int
  user: User
  project: Project
  provider: Provider
  dateAdded: DateTime
  updatedAt: DateTime
}

input CommentWhereUniqueInput {
  id: ID
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  id: IDFilter
  sentiment: IntNullableFilter
  likes: UserManyRelationFilter
  reports: UserManyRelationFilter
  user: UserWhereInput
  project: ProjectWhereInput
  provider: ProviderWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input CommentOrderByInput {
  id: OrderDirection
  sentiment: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input CommentUpdateInput {
  content: JSON
  sentiment: Int
  likes: UserRelateToManyForUpdateInput
  reports: UserRelateToManyForUpdateInput
  user: UserRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  provider: ProviderRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input CommentUpdateArgs {
  where: CommentWhereUniqueInput!
  data: CommentUpdateInput!
}

input CommentCreateInput {
  content: JSON
  sentiment: Int
  likes: UserRelateToManyForCreateInput
  reports: UserRelateToManyForCreateInput
  user: UserRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  provider: ProviderRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type ContentBlock {
  id: ID!
  title: String
  blockName: String
  enabled: Boolean
  dateAdded: DateTime
}

input ContentBlockWhereUniqueInput {
  id: ID
}

input ContentBlockWhereInput {
  AND: [ContentBlockWhereInput!]
  OR: [ContentBlockWhereInput!]
  NOT: [ContentBlockWhereInput!]
  id: IDFilter
  title: StringFilter
  blockName: StringFilter
  enabled: BooleanFilter
  dateAdded: DateTimeNullableFilter
}

input ContentBlockOrderByInput {
  id: OrderDirection
  title: OrderDirection
  blockName: OrderDirection
  enabled: OrderDirection
  dateAdded: OrderDirection
}

input ContentBlockUpdateInput {
  title: String
  blockName: String
  enabled: Boolean
  dateAdded: DateTime
}

input ContentBlockUpdateArgs {
  where: ContentBlockWhereUniqueInput!
  data: ContentBlockUpdateInput!
}

input ContentBlockCreateInput {
  title: String
  blockName: String
  enabled: Boolean
  dateAdded: DateTime
}

type ContentType {
  id: ID!
  title: String
  typeName: String
  dateAdded: DateTime
}

input ContentTypeWhereUniqueInput {
  id: ID
}

input ContentTypeWhereInput {
  AND: [ContentTypeWhereInput!]
  OR: [ContentTypeWhereInput!]
  NOT: [ContentTypeWhereInput!]
  id: IDFilter
  title: StringFilter
  typeName: StringFilter
  dateAdded: DateTimeNullableFilter
}

input ContentTypeOrderByInput {
  id: OrderDirection
  title: OrderDirection
  typeName: OrderDirection
  dateAdded: OrderDirection
}

input ContentTypeUpdateInput {
  title: String
  typeName: String
  dateAdded: DateTime
}

input ContentTypeUpdateArgs {
  where: ContentTypeWhereUniqueInput!
  data: ContentTypeUpdateInput!
}

input ContentTypeCreateInput {
  title: String
  typeName: String
  dateAdded: DateTime
}

type Image {
  id: ID!
  title: String
  slug: String
  image: ImageFieldOutput
  enabled: Boolean
  dateAdded: DateTime
}

input ImageWhereUniqueInput {
  id: ID
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  enabled: BooleanFilter
  dateAdded: DateTimeNullableFilter
}

input ImageOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  enabled: OrderDirection
  dateAdded: OrderDirection
}

input ImageUpdateInput {
  title: String
  slug: String
  image: ImageFieldInput
  enabled: Boolean
  dateAdded: DateTime
}

input ImageUpdateArgs {
  where: ImageWhereUniqueInput!
  data: ImageUpdateInput!
}

input ImageCreateInput {
  title: String
  slug: String
  image: ImageFieldInput
  enabled: Boolean
  dateAdded: DateTime
}

type Block {
  id: ID!
  project: Project
  firstBlock: Int
  previousBlock: Int
  lastBlock: Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input BlockWhereUniqueInput {
  id: ID
}

input BlockWhereInput {
  AND: [BlockWhereInput!]
  OR: [BlockWhereInput!]
  NOT: [BlockWhereInput!]
  id: IDFilter
  project: ProjectWhereInput
  firstBlock: IntNullableFilter
  previousBlock: IntNullableFilter
  lastBlock: IntNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input BlockOrderByInput {
  id: OrderDirection
  firstBlock: OrderDirection
  previousBlock: OrderDirection
  lastBlock: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input BlockUpdateInput {
  project: ProjectRelateToOneForUpdateInput
  firstBlock: Int
  previousBlock: Int
  lastBlock: Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input BlockUpdateArgs {
  where: BlockWhereUniqueInput!
  data: BlockUpdateInput!
}

input BlockCreateInput {
  project: ProjectRelateToOneForCreateInput
  firstBlock: Int
  previousBlock: Int
  lastBlock: Int
  dateAdded: DateTime
  updatedAt: DateTime
}

type Transfer {
  id: ID!
  project: Project
  amount: Float
  type: Int
  address: String
  fromAddress: String
  toAddress: String
  hash: String
  block: Int
  createdAt: DateTime
  updatedAt: DateTime
}

input TransferWhereUniqueInput {
  id: ID
}

input TransferWhereInput {
  AND: [TransferWhereInput!]
  OR: [TransferWhereInput!]
  NOT: [TransferWhereInput!]
  id: IDFilter
  project: ProjectWhereInput
  amount: FloatNullableFilter
  type: IntNullableFilter
  address: StringFilter
  fromAddress: StringFilter
  toAddress: StringFilter
  hash: StringFilter
  block: IntNullableFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input TransferOrderByInput {
  id: OrderDirection
  amount: OrderDirection
  type: OrderDirection
  address: OrderDirection
  fromAddress: OrderDirection
  toAddress: OrderDirection
  hash: OrderDirection
  block: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input TransferUpdateInput {
  project: ProjectRelateToOneForUpdateInput
  amount: Float
  type: Int
  address: String
  fromAddress: String
  toAddress: String
  hash: String
  block: Int
  createdAt: DateTime
  updatedAt: DateTime
}

input TransferUpdateArgs {
  where: TransferWhereUniqueInput!
  data: TransferUpdateInput!
}

input TransferCreateInput {
  project: ProjectRelateToOneForCreateInput
  amount: Float
  type: Int
  address: String
  fromAddress: String
  toAddress: String
  hash: String
  block: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type Holder {
  id: ID!
  address: String
  balance: Float
  note: String
  isContract: Boolean
  projects: Project
  transfers(
    where: TransferWhereInput! = {}
    orderBy: [TransferOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Transfer!]
  transfersCount(where: TransferWhereInput! = {}): Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input HolderWhereUniqueInput {
  id: ID
}

input HolderWhereInput {
  AND: [HolderWhereInput!]
  OR: [HolderWhereInput!]
  NOT: [HolderWhereInput!]
  id: IDFilter
  address: StringFilter
  balance: FloatNullableFilter
  note: StringFilter
  isContract: BooleanFilter
  projects: ProjectWhereInput
  transfers: TransferManyRelationFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input TransferManyRelationFilter {
  every: TransferWhereInput
  some: TransferWhereInput
  none: TransferWhereInput
}

input HolderOrderByInput {
  id: OrderDirection
  address: OrderDirection
  balance: OrderDirection
  note: OrderDirection
  isContract: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input HolderUpdateInput {
  address: String
  balance: Float
  note: String
  isContract: Boolean
  projects: ProjectRelateToOneForUpdateInput
  transfers: TransferRelateToManyForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input TransferRelateToManyForUpdateInput {
  disconnect: [TransferWhereUniqueInput!]
  set: [TransferWhereUniqueInput!]
  create: [TransferCreateInput!]
  connect: [TransferWhereUniqueInput!]
}

input HolderUpdateArgs {
  where: HolderWhereUniqueInput!
  data: HolderUpdateInput!
}

input HolderCreateInput {
  address: String
  balance: Float
  note: String
  isContract: Boolean
  projects: ProjectRelateToOneForCreateInput
  transfers: TransferRelateToManyForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input TransferRelateToManyForCreateInput {
  create: [TransferCreateInput!]
  connect: [TransferWhereUniqueInput!]
}

type Provider {
  id: ID!
  name: String
  slug: String
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tagsCount(where: TagWhereInput! = {}): Int
  contactEmail: String
  isPromoted: Boolean
  enabled: Boolean
  isListed: Boolean
  displayEmail: Boolean
  openForWork: Boolean
  displayPrices: Boolean
  nickname: String
  image: ImageFieldOutput
  backgroundImage: ImageFieldOutput
  summary: String
  about: String
  offers: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  views: Float
  user: User
  followers(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  followersCount(where: UserWhereInput! = {}): Int
  votes(
    where: VoteWhereInput! = {}
    orderBy: [VoteOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Vote!]
  votesCount(where: VoteWhereInput! = {}): Int
  comments(
    where: CommentWhereInput! = {}
    orderBy: [CommentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Comment!]
  commentsCount(where: CommentWhereInput! = {}): Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProviderWhereUniqueInput {
  id: ID
}

input ProviderWhereInput {
  AND: [ProviderWhereInput!]
  OR: [ProviderWhereInput!]
  NOT: [ProviderWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  tags: TagManyRelationFilter
  contactEmail: StringFilter
  isPromoted: BooleanFilter
  enabled: BooleanFilter
  isListed: BooleanFilter
  displayEmail: BooleanFilter
  openForWork: BooleanFilter
  displayPrices: BooleanFilter
  nickname: StringFilter
  summary: StringFilter
  about: StringFilter
  offers: StringFilter
  website: StringFilter
  twitter: StringFilter
  telegram: StringFilter
  discord: StringFilter
  reddit: StringFilter
  youtube: StringFilter
  priceFrom: FloatNullableFilter
  priceTo: FloatNullableFilter
  views: FloatNullableFilter
  user: UserWhereInput
  followers: UserManyRelationFilter
  votes: VoteManyRelationFilter
  comments: CommentManyRelationFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input ProviderOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  contactEmail: OrderDirection
  isPromoted: OrderDirection
  enabled: OrderDirection
  isListed: OrderDirection
  displayEmail: OrderDirection
  openForWork: OrderDirection
  displayPrices: OrderDirection
  nickname: OrderDirection
  summary: OrderDirection
  about: OrderDirection
  offers: OrderDirection
  website: OrderDirection
  twitter: OrderDirection
  telegram: OrderDirection
  discord: OrderDirection
  reddit: OrderDirection
  youtube: OrderDirection
  priceFrom: OrderDirection
  priceTo: OrderDirection
  views: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input ProviderUpdateInput {
  name: String
  slug: String
  tags: TagRelateToManyForUpdateInput
  contactEmail: String
  isPromoted: Boolean
  enabled: Boolean
  isListed: Boolean
  displayEmail: Boolean
  openForWork: Boolean
  displayPrices: Boolean
  nickname: String
  image: ImageFieldInput
  backgroundImage: ImageFieldInput
  summary: String
  about: String
  offers: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  views: Float
  user: UserRelateToOneForUpdateInput
  followers: UserRelateToManyForUpdateInput
  votes: VoteRelateToManyForUpdateInput
  comments: CommentRelateToManyForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProviderUpdateArgs {
  where: ProviderWhereUniqueInput!
  data: ProviderUpdateInput!
}

input ProviderCreateInput {
  name: String
  slug: String
  tags: TagRelateToManyForCreateInput
  contactEmail: String
  isPromoted: Boolean
  enabled: Boolean
  isListed: Boolean
  displayEmail: Boolean
  openForWork: Boolean
  displayPrices: Boolean
  nickname: String
  image: ImageFieldInput
  backgroundImage: ImageFieldInput
  summary: String
  about: String
  offers: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  views: Float
  user: UserRelateToOneForCreateInput
  followers: UserRelateToManyForCreateInput
  votes: VoteRelateToManyForCreateInput
  comments: CommentRelateToManyForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type Auditor {
  id: ID!
  name: String
  slug: String
  enabled: Boolean
  isListed: Boolean
  image: ImageFieldOutput
  description: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input AuditorWhereUniqueInput {
  id: ID
}

input AuditorWhereInput {
  AND: [AuditorWhereInput!]
  OR: [AuditorWhereInput!]
  NOT: [AuditorWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  enabled: BooleanFilter
  isListed: BooleanFilter
  description: StringFilter
  website: StringFilter
  twitter: StringFilter
  telegram: StringFilter
  discord: StringFilter
  reddit: StringFilter
  youtube: StringFilter
  priceFrom: FloatNullableFilter
  priceTo: FloatNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input AuditorOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  enabled: OrderDirection
  isListed: OrderDirection
  description: OrderDirection
  website: OrderDirection
  twitter: OrderDirection
  telegram: OrderDirection
  discord: OrderDirection
  reddit: OrderDirection
  youtube: OrderDirection
  priceFrom: OrderDirection
  priceTo: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input AuditorUpdateInput {
  name: String
  slug: String
  enabled: Boolean
  isListed: Boolean
  image: ImageFieldInput
  description: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input AuditorUpdateArgs {
  where: AuditorWhereUniqueInput!
  data: AuditorUpdateInput!
}

input AuditorCreateInput {
  name: String
  slug: String
  enabled: Boolean
  isListed: Boolean
  image: ImageFieldInput
  description: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

type KycGroup {
  id: ID!
  name: String
  slug: String
  enabled: Boolean
  isListed: Boolean
  image: ImageFieldOutput
  description: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input KycGroupWhereUniqueInput {
  id: ID
}

input KycGroupWhereInput {
  AND: [KycGroupWhereInput!]
  OR: [KycGroupWhereInput!]
  NOT: [KycGroupWhereInput!]
  id: IDFilter
  name: StringFilter
  slug: StringFilter
  enabled: BooleanFilter
  isListed: BooleanFilter
  description: StringFilter
  website: StringFilter
  twitter: StringFilter
  telegram: StringFilter
  discord: StringFilter
  reddit: StringFilter
  youtube: StringFilter
  priceFrom: FloatNullableFilter
  priceTo: FloatNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input KycGroupOrderByInput {
  id: OrderDirection
  name: OrderDirection
  slug: OrderDirection
  enabled: OrderDirection
  isListed: OrderDirection
  description: OrderDirection
  website: OrderDirection
  twitter: OrderDirection
  telegram: OrderDirection
  discord: OrderDirection
  reddit: OrderDirection
  youtube: OrderDirection
  priceFrom: OrderDirection
  priceTo: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input KycGroupUpdateInput {
  name: String
  slug: String
  enabled: Boolean
  isListed: Boolean
  image: ImageFieldInput
  description: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input KycGroupUpdateArgs {
  where: KycGroupWhereUniqueInput!
  data: KycGroupUpdateInput!
}

input KycGroupCreateInput {
  name: String
  slug: String
  enabled: Boolean
  isListed: Boolean
  image: ImageFieldInput
  description: String
  website: String
  twitter: String
  telegram: String
  discord: String
  reddit: String
  youtube: String
  priceFrom: Float
  priceTo: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

type TransparencyRating {
  id: ID!
  rating: Int
  ip: String
  user: User
  project: Project
  dateAdded: DateTime
  updatedAt: DateTime
}

input TransparencyRatingWhereUniqueInput {
  id: ID
}

input TransparencyRatingWhereInput {
  AND: [TransparencyRatingWhereInput!]
  OR: [TransparencyRatingWhereInput!]
  NOT: [TransparencyRatingWhereInput!]
  id: IDFilter
  rating: IntNullableFilter
  ip: StringFilter
  user: UserWhereInput
  project: ProjectWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input TransparencyRatingOrderByInput {
  id: OrderDirection
  rating: OrderDirection
  ip: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input TransparencyRatingUpdateInput {
  rating: Int
  ip: String
  user: UserRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input TransparencyRatingUpdateArgs {
  where: TransparencyRatingWhereUniqueInput!
  data: TransparencyRatingUpdateInput!
}

input TransparencyRatingCreateInput {
  rating: Int
  ip: String
  user: UserRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type MarketingCampaign {
  id: ID!
  name: String
  campaignId: String
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  enabled: Boolean
  status: String
  isInternal: Boolean
  trackMarket: Boolean
  trackSocial: Boolean
  startDate: CalendarDay
  endDate: CalendarDay
  budget: Float
  description: String
  notes: String
  agency: String
  agencyUrl: String
  project: Project
  marketStatSnapshot: JSON
  finalSnapshot: JSON
  marketBudget: Float
  socialBudget: Float
  priceGoal: Float
  marketCapGoal: Float
  volumeGoal: Float
  holdersGoal: Float
  twitterGoal: Float
  discordGoal: Float
  telegramGoal: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

scalar CalendarDay
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input MarketingCampaignWhereUniqueInput {
  id: ID
}

input MarketingCampaignWhereInput {
  AND: [MarketingCampaignWhereInput!]
  OR: [MarketingCampaignWhereInput!]
  NOT: [MarketingCampaignWhereInput!]
  id: IDFilter
  name: StringFilter
  campaignId: StringFilter
  users: UserManyRelationFilter
  enabled: BooleanFilter
  status: StringNullableFilter
  isInternal: BooleanFilter
  trackMarket: BooleanFilter
  trackSocial: BooleanFilter
  startDate: CalendarDayNullableFilter
  endDate: CalendarDayNullableFilter
  budget: FloatNullableFilter
  description: StringFilter
  notes: StringFilter
  agency: StringFilter
  agencyUrl: StringFilter
  project: ProjectWhereInput
  marketBudget: FloatNullableFilter
  socialBudget: FloatNullableFilter
  priceGoal: FloatNullableFilter
  marketCapGoal: FloatNullableFilter
  volumeGoal: FloatNullableFilter
  holdersGoal: FloatNullableFilter
  twitterGoal: FloatNullableFilter
  discordGoal: FloatNullableFilter
  telegramGoal: FloatNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input CalendarDayNullableFilter {
  equals: CalendarDay
  in: [CalendarDay!]
  notIn: [CalendarDay!]
  lt: CalendarDay
  lte: CalendarDay
  gt: CalendarDay
  gte: CalendarDay
  not: CalendarDayNullableFilter
}

input MarketingCampaignOrderByInput {
  id: OrderDirection
  name: OrderDirection
  campaignId: OrderDirection
  enabled: OrderDirection
  status: OrderDirection
  isInternal: OrderDirection
  trackMarket: OrderDirection
  trackSocial: OrderDirection
  startDate: OrderDirection
  endDate: OrderDirection
  budget: OrderDirection
  description: OrderDirection
  notes: OrderDirection
  agency: OrderDirection
  agencyUrl: OrderDirection
  marketBudget: OrderDirection
  socialBudget: OrderDirection
  priceGoal: OrderDirection
  marketCapGoal: OrderDirection
  volumeGoal: OrderDirection
  holdersGoal: OrderDirection
  twitterGoal: OrderDirection
  discordGoal: OrderDirection
  telegramGoal: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input MarketingCampaignUpdateInput {
  name: String
  campaignId: String
  users: UserRelateToManyForUpdateInput
  enabled: Boolean
  status: String
  isInternal: Boolean
  trackMarket: Boolean
  trackSocial: Boolean
  startDate: CalendarDay
  endDate: CalendarDay
  budget: Float
  description: String
  notes: String
  agency: String
  agencyUrl: String
  project: ProjectRelateToOneForUpdateInput
  marketStatSnapshot: JSON
  finalSnapshot: JSON
  marketBudget: Float
  socialBudget: Float
  priceGoal: Float
  marketCapGoal: Float
  volumeGoal: Float
  holdersGoal: Float
  twitterGoal: Float
  discordGoal: Float
  telegramGoal: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input MarketingCampaignUpdateArgs {
  where: MarketingCampaignWhereUniqueInput!
  data: MarketingCampaignUpdateInput!
}

input MarketingCampaignCreateInput {
  name: String
  campaignId: String
  users: UserRelateToManyForCreateInput
  enabled: Boolean
  status: String
  isInternal: Boolean
  trackMarket: Boolean
  trackSocial: Boolean
  startDate: CalendarDay
  endDate: CalendarDay
  budget: Float
  description: String
  notes: String
  agency: String
  agencyUrl: String
  project: ProjectRelateToOneForCreateInput
  marketStatSnapshot: JSON
  finalSnapshot: JSON
  marketBudget: Float
  socialBudget: Float
  priceGoal: Float
  marketCapGoal: Float
  volumeGoal: Float
  holdersGoal: Float
  twitterGoal: Float
  discordGoal: Float
  telegramGoal: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

type MarketingTrackerResult {
  id: ID!
  referer: String
  ipAddress: String
  userAgent: String
  device: String
  os: String
  timezone: String
  city: String
  country: String
  countryCode: String
  target: String
  marketingCampaign: MarketingCampaign
  dateAdded: DateTime
  updatedAt: DateTime
  totalClicks(campaignId: String): JSON
  countryResults(campaignId: String): JSON
  deviceResults(campaignId: String): JSON
  refererResults(campaignId: String): JSON
  uniqueClicks(campaignId: String): Int
  socialClicks(campaignId: String): JSON
}

input MarketingTrackerResultWhereUniqueInput {
  id: ID
}

input MarketingTrackerResultWhereInput {
  AND: [MarketingTrackerResultWhereInput!]
  OR: [MarketingTrackerResultWhereInput!]
  NOT: [MarketingTrackerResultWhereInput!]
  id: IDFilter
  referer: StringFilter
  ipAddress: StringFilter
  userAgent: StringFilter
  device: StringFilter
  os: StringFilter
  timezone: StringFilter
  city: StringFilter
  country: StringFilter
  countryCode: StringFilter
  target: StringFilter
  marketingCampaign: MarketingCampaignWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input MarketingTrackerResultOrderByInput {
  id: OrderDirection
  referer: OrderDirection
  ipAddress: OrderDirection
  userAgent: OrderDirection
  device: OrderDirection
  os: OrderDirection
  timezone: OrderDirection
  city: OrderDirection
  country: OrderDirection
  countryCode: OrderDirection
  target: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input MarketingTrackerResultUpdateInput {
  referer: String
  ipAddress: String
  userAgent: String
  device: String
  os: String
  timezone: String
  city: String
  country: String
  countryCode: String
  target: String
  marketingCampaign: MarketingCampaignRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input MarketingCampaignRelateToOneForUpdateInput {
  create: MarketingCampaignCreateInput
  connect: MarketingCampaignWhereUniqueInput
  disconnect: Boolean
}

input MarketingTrackerResultUpdateArgs {
  where: MarketingTrackerResultWhereUniqueInput!
  data: MarketingTrackerResultUpdateInput!
}

input MarketingTrackerResultCreateInput {
  referer: String
  ipAddress: String
  userAgent: String
  device: String
  os: String
  timezone: String
  city: String
  country: String
  countryCode: String
  target: String
  marketingCampaign: MarketingCampaignRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input MarketingCampaignRelateToOneForCreateInput {
  create: MarketingCampaignCreateInput
  connect: MarketingCampaignWhereUniqueInput
}

type Cart {
  id: ID!
  user: User
  cartItem: CartItem
  couponCode: Coupon
  dateAdded: DateTime
  updatedAt: DateTime
}

input CartWhereUniqueInput {
  id: ID
}

input CartWhereInput {
  AND: [CartWhereInput!]
  OR: [CartWhereInput!]
  NOT: [CartWhereInput!]
  id: IDFilter
  user: UserWhereInput
  cartItem: CartItemWhereInput
  couponCode: CouponWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input CartOrderByInput {
  id: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input CartUpdateInput {
  user: UserRelateToOneForUpdateInput
  cartItem: CartItemRelateToOneForUpdateInput
  couponCode: CouponRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input CartItemRelateToOneForUpdateInput {
  create: CartItemCreateInput
  connect: CartItemWhereUniqueInput
  disconnect: Boolean
}

input CouponRelateToOneForUpdateInput {
  create: CouponCreateInput
  connect: CouponWhereUniqueInput
  disconnect: Boolean
}

input CartUpdateArgs {
  where: CartWhereUniqueInput!
  data: CartUpdateInput!
}

input CartCreateInput {
  user: UserRelateToOneForCreateInput
  cartItem: CartItemRelateToOneForCreateInput
  couponCode: CouponRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input CartItemRelateToOneForCreateInput {
  create: CartItemCreateInput
  connect: CartItemWhereUniqueInput
}

input CouponRelateToOneForCreateInput {
  create: CouponCreateInput
  connect: CouponWhereUniqueInput
}

type CartItem {
  id: ID!
  product: Product
  paymentPlan: PaymentPlan
  cart: Cart
  price: Float
  tax: Float
  discount: Float
  quantity: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input CartItemWhereUniqueInput {
  id: ID
}

input CartItemWhereInput {
  AND: [CartItemWhereInput!]
  OR: [CartItemWhereInput!]
  NOT: [CartItemWhereInput!]
  id: IDFilter
  product: ProductWhereInput
  paymentPlan: PaymentPlanWhereInput
  cart: CartWhereInput
  price: FloatNullableFilter
  tax: FloatNullableFilter
  discount: FloatNullableFilter
  quantity: FloatNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input CartItemOrderByInput {
  id: OrderDirection
  price: OrderDirection
  tax: OrderDirection
  discount: OrderDirection
  quantity: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input CartItemUpdateInput {
  product: ProductRelateToOneForUpdateInput
  paymentPlan: PaymentPlanRelateToOneForUpdateInput
  cart: CartRelateToOneForUpdateInput
  price: Float
  tax: Float
  discount: Float
  quantity: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProductRelateToOneForUpdateInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
  disconnect: Boolean
}

input CartRelateToOneForUpdateInput {
  create: CartCreateInput
  connect: CartWhereUniqueInput
  disconnect: Boolean
}

input CartItemUpdateArgs {
  where: CartItemWhereUniqueInput!
  data: CartItemUpdateInput!
}

input CartItemCreateInput {
  product: ProductRelateToOneForCreateInput
  paymentPlan: PaymentPlanRelateToOneForCreateInput
  cart: CartRelateToOneForCreateInput
  price: Float
  tax: Float
  discount: Float
  quantity: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input ProductRelateToOneForCreateInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

input CartRelateToOneForCreateInput {
  create: CartCreateInput
  connect: CartWhereUniqueInput
}

type Order {
  id: ID!
  orderNumber: Int
  user: User
  orderItem: OrderItem
  project: Project
  walletAddress: String
  transactionHash: String
  currency: String
  currencyPriceEur: Float
  durationInMonths: Float
  paymentNetwork: Network
  discount: Float
  tax: Float
  total: Float
  subTotal: Float
  grandTotal: Float
  couponCode: Coupon
  dateAdded: DateTime
  updatedAt: DateTime
}

input OrderWhereUniqueInput {
  id: ID
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
  id: IDFilter
  orderNumber: IntFilter
  user: UserWhereInput
  orderItem: OrderItemWhereInput
  project: ProjectWhereInput
  walletAddress: StringFilter
  transactionHash: StringFilter
  currency: StringFilter
  currencyPriceEur: FloatNullableFilter
  durationInMonths: FloatNullableFilter
  paymentNetwork: NetworkWhereInput
  discount: FloatNullableFilter
  tax: FloatNullableFilter
  total: FloatNullableFilter
  subTotal: FloatNullableFilter
  grandTotal: FloatNullableFilter
  couponCode: CouponWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntFilter
}

input OrderOrderByInput {
  id: OrderDirection
  orderNumber: OrderDirection
  walletAddress: OrderDirection
  transactionHash: OrderDirection
  currency: OrderDirection
  currencyPriceEur: OrderDirection
  durationInMonths: OrderDirection
  discount: OrderDirection
  tax: OrderDirection
  total: OrderDirection
  subTotal: OrderDirection
  grandTotal: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input OrderUpdateInput {
  orderNumber: Int
  user: UserRelateToOneForUpdateInput
  orderItem: OrderItemRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  walletAddress: String
  transactionHash: String
  currency: String
  currencyPriceEur: Float
  durationInMonths: Float
  paymentNetwork: NetworkRelateToOneForUpdateInput
  discount: Float
  tax: Float
  total: Float
  subTotal: Float
  grandTotal: Float
  couponCode: CouponRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input OrderItemRelateToOneForUpdateInput {
  create: OrderItemCreateInput
  connect: OrderItemWhereUniqueInput
  disconnect: Boolean
}

input OrderUpdateArgs {
  where: OrderWhereUniqueInput!
  data: OrderUpdateInput!
}

input OrderCreateInput {
  orderNumber: Int
  user: UserRelateToOneForCreateInput
  orderItem: OrderItemRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  walletAddress: String
  transactionHash: String
  currency: String
  currencyPriceEur: Float
  durationInMonths: Float
  paymentNetwork: NetworkRelateToOneForCreateInput
  discount: Float
  tax: Float
  total: Float
  subTotal: Float
  grandTotal: Float
  couponCode: CouponRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input OrderItemRelateToOneForCreateInput {
  create: OrderItemCreateInput
  connect: OrderItemWhereUniqueInput
}

type OrderItem {
  id: ID!
  order: Order
  product: Product
  paymentPlan: PaymentPlan
  price: Float
  quantity: Float
  discount: Float
  tax: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input OrderItemWhereUniqueInput {
  id: ID
}

input OrderItemWhereInput {
  AND: [OrderItemWhereInput!]
  OR: [OrderItemWhereInput!]
  NOT: [OrderItemWhereInput!]
  id: IDFilter
  order: OrderWhereInput
  product: ProductWhereInput
  paymentPlan: PaymentPlanWhereInput
  price: FloatNullableFilter
  quantity: FloatNullableFilter
  discount: FloatNullableFilter
  tax: FloatNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input OrderItemOrderByInput {
  id: OrderDirection
  price: OrderDirection
  quantity: OrderDirection
  discount: OrderDirection
  tax: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input OrderItemUpdateInput {
  order: OrderRelateToOneForUpdateInput
  product: ProductRelateToOneForUpdateInput
  paymentPlan: PaymentPlanRelateToOneForUpdateInput
  price: Float
  quantity: Float
  discount: Float
  tax: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

input OrderItemUpdateArgs {
  where: OrderItemWhereUniqueInput!
  data: OrderItemUpdateInput!
}

input OrderItemCreateInput {
  order: OrderRelateToOneForCreateInput
  product: ProductRelateToOneForCreateInput
  paymentPlan: PaymentPlanRelateToOneForCreateInput
  price: Float
  quantity: Float
  discount: Float
  tax: Float
  dateAdded: DateTime
  updatedAt: DateTime
}

type Vote {
  id: ID!
  vote: Int
  ip: String
  type: String
  user: User
  project: Project
  provider: Provider
  dateAdded: DateTime
  updatedAt: DateTime
}

input VoteWhereUniqueInput {
  id: ID
}

input VoteWhereInput {
  AND: [VoteWhereInput!]
  OR: [VoteWhereInput!]
  NOT: [VoteWhereInput!]
  id: IDFilter
  vote: IntNullableFilter
  ip: StringFilter
  type: StringNullableFilter
  user: UserWhereInput
  project: ProjectWhereInput
  provider: ProviderWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input VoteOrderByInput {
  id: OrderDirection
  vote: OrderDirection
  ip: OrderDirection
  type: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input VoteUpdateInput {
  vote: Int
  ip: String
  type: String
  user: UserRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  provider: ProviderRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input VoteUpdateArgs {
  where: VoteWhereUniqueInput!
  data: VoteUpdateInput!
}

input VoteCreateInput {
  vote: Int
  ip: String
  type: String
  user: UserRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  provider: ProviderRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type Quiz {
  id: ID!
  title: String
  slug: String
  imageUrl: String
  image: ImageFieldOutput
  enabled: Boolean
  hasRewards: Boolean
  rewardsAmount: Int
  rewardType: String
  description: JSON
  onWinDescription: JSON
  onEndDescription: JSON
  config: JSON
  totalWinners: Int
  winners: Int
  timePerQuestion: Int
  views: Int
  project: Project
  user: User
  likes(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  likesCount(where: UserWhereInput! = {}): Int
  startDate: DateTime
  endDate: DateTime
  dateAdded: DateTime
  updatedAt: DateTime
}

input QuizWhereUniqueInput {
  id: ID
}

input QuizWhereInput {
  AND: [QuizWhereInput!]
  OR: [QuizWhereInput!]
  NOT: [QuizWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  imageUrl: StringFilter
  enabled: BooleanFilter
  hasRewards: BooleanFilter
  rewardsAmount: IntNullableFilter
  rewardType: StringFilter
  totalWinners: IntNullableFilter
  winners: IntNullableFilter
  timePerQuestion: IntNullableFilter
  views: IntNullableFilter
  project: ProjectWhereInput
  user: UserWhereInput
  likes: UserManyRelationFilter
  startDate: DateTimeNullableFilter
  endDate: DateTimeNullableFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input QuizOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  imageUrl: OrderDirection
  enabled: OrderDirection
  hasRewards: OrderDirection
  rewardsAmount: OrderDirection
  rewardType: OrderDirection
  totalWinners: OrderDirection
  winners: OrderDirection
  timePerQuestion: OrderDirection
  views: OrderDirection
  startDate: OrderDirection
  endDate: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input QuizUpdateInput {
  title: String
  slug: String
  imageUrl: String
  image: ImageFieldInput
  enabled: Boolean
  hasRewards: Boolean
  rewardsAmount: Int
  rewardType: String
  description: JSON
  onWinDescription: JSON
  onEndDescription: JSON
  config: JSON
  totalWinners: Int
  winners: Int
  timePerQuestion: Int
  views: Int
  project: ProjectRelateToOneForUpdateInput
  user: UserRelateToOneForUpdateInput
  likes: UserRelateToManyForUpdateInput
  startDate: DateTime
  endDate: DateTime
  dateAdded: DateTime
  updatedAt: DateTime
}

input QuizUpdateArgs {
  where: QuizWhereUniqueInput!
  data: QuizUpdateInput!
}

input QuizCreateInput {
  title: String
  slug: String
  imageUrl: String
  image: ImageFieldInput
  enabled: Boolean
  hasRewards: Boolean
  rewardsAmount: Int
  rewardType: String
  description: JSON
  onWinDescription: JSON
  onEndDescription: JSON
  config: JSON
  totalWinners: Int
  winners: Int
  timePerQuestion: Int
  views: Int
  project: ProjectRelateToOneForCreateInput
  user: UserRelateToOneForCreateInput
  likes: UserRelateToManyForCreateInput
  startDate: DateTime
  endDate: DateTime
  dateAdded: DateTime
  updatedAt: DateTime
}

type Transcription {
  id: ID!
  title: String
  slug: String
  summary: String
  transcriptionId: String
  isPublic: Boolean
  contentUrl: String
  content: JSON
  user: User
  project: Project
  views: Int
  likes(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  likesCount(where: UserWhereInput! = {}): Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input TranscriptionWhereUniqueInput {
  id: ID
}

input TranscriptionWhereInput {
  AND: [TranscriptionWhereInput!]
  OR: [TranscriptionWhereInput!]
  NOT: [TranscriptionWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  summary: StringFilter
  transcriptionId: StringFilter
  isPublic: BooleanFilter
  contentUrl: StringFilter
  user: UserWhereInput
  project: ProjectWhereInput
  views: IntNullableFilter
  likes: UserManyRelationFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input TranscriptionOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  summary: OrderDirection
  transcriptionId: OrderDirection
  isPublic: OrderDirection
  contentUrl: OrderDirection
  views: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input TranscriptionUpdateInput {
  title: String
  slug: String
  summary: String
  transcriptionId: String
  isPublic: Boolean
  contentUrl: String
  content: JSON
  user: UserRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  views: Int
  likes: UserRelateToManyForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input TranscriptionUpdateArgs {
  where: TranscriptionWhereUniqueInput!
  data: TranscriptionUpdateInput!
}

input TranscriptionCreateInput {
  title: String
  slug: String
  summary: String
  transcriptionId: String
  isPublic: Boolean
  contentUrl: String
  content: JSON
  user: UserRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  views: Int
  likes: UserRelateToManyForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type EmailList {
  id: ID!
  email: String
  dateAdded: DateTime
  updatedAt: DateTime
}

input EmailListWhereUniqueInput {
  id: ID
  email: String
}

input EmailListWhereInput {
  AND: [EmailListWhereInput!]
  OR: [EmailListWhereInput!]
  NOT: [EmailListWhereInput!]
  id: IDFilter
  email: StringFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input EmailListOrderByInput {
  id: OrderDirection
  email: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input EmailListUpdateInput {
  email: String
  dateAdded: DateTime
  updatedAt: DateTime
}

input EmailListUpdateArgs {
  where: EmailListWhereUniqueInput!
  data: EmailListUpdateInput!
}

input EmailListCreateInput {
  email: String
  dateAdded: DateTime
  updatedAt: DateTime
}

type ServiceToken {
  id: ID!
  amount: Float
  discount: Float
  user: User
  tokenUsage(
    where: ServiceTokenUsageWhereInput! = {}
    orderBy: [ServiceTokenUsageOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [ServiceTokenUsage!]
  tokenUsageCount(where: ServiceTokenUsageWhereInput! = {}): Int
  dateAdded: DateTime
  updatedAt: DateTime
}

input ServiceTokenWhereUniqueInput {
  id: ID
}

input ServiceTokenWhereInput {
  AND: [ServiceTokenWhereInput!]
  OR: [ServiceTokenWhereInput!]
  NOT: [ServiceTokenWhereInput!]
  id: IDFilter
  amount: FloatNullableFilter
  discount: FloatNullableFilter
  user: UserWhereInput
  tokenUsage: ServiceTokenUsageManyRelationFilter
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input ServiceTokenUsageManyRelationFilter {
  every: ServiceTokenUsageWhereInput
  some: ServiceTokenUsageWhereInput
  none: ServiceTokenUsageWhereInput
}

input ServiceTokenOrderByInput {
  id: OrderDirection
  amount: OrderDirection
  discount: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input ServiceTokenUpdateInput {
  amount: Float
  discount: Float
  user: UserRelateToOneForUpdateInput
  tokenUsage: ServiceTokenUsageRelateToManyForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input ServiceTokenUsageRelateToManyForUpdateInput {
  disconnect: [ServiceTokenUsageWhereUniqueInput!]
  set: [ServiceTokenUsageWhereUniqueInput!]
  create: [ServiceTokenUsageCreateInput!]
  connect: [ServiceTokenUsageWhereUniqueInput!]
}

input ServiceTokenUpdateArgs {
  where: ServiceTokenWhereUniqueInput!
  data: ServiceTokenUpdateInput!
}

input ServiceTokenCreateInput {
  amount: Float
  discount: Float
  user: UserRelateToOneForCreateInput
  tokenUsage: ServiceTokenUsageRelateToManyForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input ServiceTokenUsageRelateToManyForCreateInput {
  create: [ServiceTokenUsageCreateInput!]
  connect: [ServiceTokenUsageWhereUniqueInput!]
}

type ServiceTokenUsage {
  id: ID!
  used: Float
  description: String
  serviceToken: ServiceToken
  dateAdded: DateTime
  updatedAt: DateTime
}

input ServiceTokenUsageWhereUniqueInput {
  id: ID
}

input ServiceTokenUsageWhereInput {
  AND: [ServiceTokenUsageWhereInput!]
  OR: [ServiceTokenUsageWhereInput!]
  NOT: [ServiceTokenUsageWhereInput!]
  id: IDFilter
  used: FloatNullableFilter
  description: StringFilter
  serviceToken: ServiceTokenWhereInput
  dateAdded: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input ServiceTokenUsageOrderByInput {
  id: OrderDirection
  used: OrderDirection
  description: OrderDirection
  dateAdded: OrderDirection
  updatedAt: OrderDirection
}

input ServiceTokenUsageUpdateInput {
  used: Float
  description: String
  serviceToken: ServiceTokenRelateToOneForUpdateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

input ServiceTokenUsageUpdateArgs {
  where: ServiceTokenUsageWhereUniqueInput!
  data: ServiceTokenUsageUpdateInput!
}

input ServiceTokenUsageCreateInput {
  used: Float
  description: String
  serviceToken: ServiceTokenRelateToOneForCreateInput
  dateAdded: DateTime
  updatedAt: DateTime
}

type Account {
  id: ID!
  user: UserAuth
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
}

input AccountWhereUniqueInput {
  id: ID
  providerAccountId: String
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  id: IDFilter
  user: UserAuthWhereInput
  type: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringFilter
  access_token: StringFilter
  expires_at: IntNullableFilter
  token_type: StringFilter
  scope: StringFilter
  id_token: StringFilter
  session_state: StringFilter
}

input AccountOrderByInput {
  id: OrderDirection
  type: OrderDirection
  provider: OrderDirection
  providerAccountId: OrderDirection
  refresh_token: OrderDirection
  access_token: OrderDirection
  expires_at: OrderDirection
  token_type: OrderDirection
  scope: OrderDirection
  id_token: OrderDirection
  session_state: OrderDirection
}

input AccountUpdateInput {
  user: UserAuthRelateToOneForUpdateInput
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
}

input AccountUpdateArgs {
  where: AccountWhereUniqueInput!
  data: AccountUpdateInput!
}

input AccountCreateInput {
  user: UserAuthRelateToOneForCreateInput
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
}

type Session {
  id: ID!
  user: UserAuth
  sessionToken: String
  expires: DateTime
}

input SessionWhereUniqueInput {
  id: ID
  sessionToken: String
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  id: IDFilter
  user: UserAuthWhereInput
  sessionToken: StringFilter
  expires: DateTimeNullableFilter
}

input SessionOrderByInput {
  id: OrderDirection
  sessionToken: OrderDirection
  expires: OrderDirection
}

input SessionUpdateInput {
  user: UserAuthRelateToOneForUpdateInput
  sessionToken: String
  expires: DateTime
}

input SessionUpdateArgs {
  where: SessionWhereUniqueInput!
  data: SessionUpdateInput!
}

input SessionCreateInput {
  user: UserAuthRelateToOneForCreateInput
  sessionToken: String
  expires: DateTime
}

type VerificationToken {
  id: ID!
  identifier: String
  token: String
  expires: DateTime
}

input VerificationTokenWhereUniqueInput {
  id: ID
  token: String
}

input VerificationTokenWhereInput {
  AND: [VerificationTokenWhereInput!]
  OR: [VerificationTokenWhereInput!]
  NOT: [VerificationTokenWhereInput!]
  id: IDFilter
  identifier: StringFilter
  token: StringFilter
  expires: DateTimeNullableFilter
}

input VerificationTokenOrderByInput {
  id: OrderDirection
  identifier: OrderDirection
  token: OrderDirection
  expires: OrderDirection
}

input VerificationTokenUpdateInput {
  identifier: String
  token: String
  expires: DateTime
}

input VerificationTokenUpdateArgs {
  where: VerificationTokenWhereUniqueInput!
  data: VerificationTokenUpdateInput!
}

input VerificationTokenCreateInput {
  identifier: String
  token: String
  expires: DateTime
}

type UserAuth {
  id: ID!
  name: String
  email: String
  emailVerified: DateTime
  image: String
  user: User
  access_token: String
  accounts(
    where: AccountWhereInput! = {}
    orderBy: [AccountOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Account!]
  accountsCount(where: AccountWhereInput! = {}): Int
  sessions(
    where: SessionWhereInput! = {}
    orderBy: [SessionOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Session!]
  sessionsCount(where: SessionWhereInput! = {}): Int
}

input UserAuthWhereUniqueInput {
  id: ID
  email: String
}

input UserAuthWhereInput {
  AND: [UserAuthWhereInput!]
  OR: [UserAuthWhereInput!]
  NOT: [UserAuthWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  image: StringFilter
  user: UserWhereInput
  access_token: StringFilter
  accounts: AccountManyRelationFilter
  sessions: SessionManyRelationFilter
}

input AccountManyRelationFilter {
  every: AccountWhereInput
  some: AccountWhereInput
  none: AccountWhereInput
}

input SessionManyRelationFilter {
  every: SessionWhereInput
  some: SessionWhereInput
  none: SessionWhereInput
}

input UserAuthOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  emailVerified: OrderDirection
  image: OrderDirection
  access_token: OrderDirection
}

input UserAuthUpdateInput {
  name: String
  email: String
  emailVerified: DateTime
  image: String
  user: UserRelateToOneForUpdateInput
  access_token: String
  accounts: AccountRelateToManyForUpdateInput
  sessions: SessionRelateToManyForUpdateInput
}

input AccountRelateToManyForUpdateInput {
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  create: [AccountCreateInput!]
  connect: [AccountWhereUniqueInput!]
}

input SessionRelateToManyForUpdateInput {
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  create: [SessionCreateInput!]
  connect: [SessionWhereUniqueInput!]
}

input UserAuthUpdateArgs {
  where: UserAuthWhereUniqueInput!
  data: UserAuthUpdateInput!
}

input UserAuthCreateInput {
  name: String
  email: String
  emailVerified: DateTime
  image: String
  user: UserRelateToOneForCreateInput
  access_token: String
  accounts: AccountRelateToManyForCreateInput
  sessions: SessionRelateToManyForCreateInput
}

input AccountRelateToManyForCreateInput {
  create: [AccountCreateInput!]
  connect: [AccountWhereUniqueInput!]
}

input SessionRelateToManyForCreateInput {
  create: [SessionCreateInput!]
  connect: [SessionWhereUniqueInput!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createSubscription(data: SubscriptionCreateInput!): Subscription
  createSubscriptions(data: [SubscriptionCreateInput!]!): [Subscription]
  updateSubscription(
    where: SubscriptionWhereUniqueInput!
    data: SubscriptionUpdateInput!
  ): Subscription
  updateSubscriptions(data: [SubscriptionUpdateArgs!]!): [Subscription]
  deleteSubscription(where: SubscriptionWhereUniqueInput!): Subscription
  deleteSubscriptions(where: [SubscriptionWhereUniqueInput!]!): [Subscription]
  createProduct(data: ProductCreateInput!): Product
  createProducts(data: [ProductCreateInput!]!): [Product]
  updateProduct(
    where: ProductWhereUniqueInput!
    data: ProductUpdateInput!
  ): Product
  updateProducts(data: [ProductUpdateArgs!]!): [Product]
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteProducts(where: [ProductWhereUniqueInput!]!): [Product]
  createRole(data: RoleCreateInput!): Role
  createRoles(data: [RoleCreateInput!]!): [Role]
  updateRole(where: RoleWhereUniqueInput!, data: RoleUpdateInput!): Role
  updateRoles(data: [RoleUpdateArgs!]!): [Role]
  deleteRole(where: RoleWhereUniqueInput!): Role
  deleteRoles(where: [RoleWhereUniqueInput!]!): [Role]
  createProject(data: ProjectCreateInput!): Project
  createProjects(data: [ProjectCreateInput!]!): [Project]
  updateProject(
    where: ProjectWhereUniqueInput!
    data: ProjectUpdateInput!
  ): Project
  updateProjects(data: [ProjectUpdateArgs!]!): [Project]
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteProjects(where: [ProjectWhereUniqueInput!]!): [Project]
  createPaymentPlan(data: PaymentPlanCreateInput!): PaymentPlan
  createPaymentPlans(data: [PaymentPlanCreateInput!]!): [PaymentPlan]
  updatePaymentPlan(
    where: PaymentPlanWhereUniqueInput!
    data: PaymentPlanUpdateInput!
  ): PaymentPlan
  updatePaymentPlans(data: [PaymentPlanUpdateArgs!]!): [PaymentPlan]
  deletePaymentPlan(where: PaymentPlanWhereUniqueInput!): PaymentPlan
  deletePaymentPlans(where: [PaymentPlanWhereUniqueInput!]!): [PaymentPlan]
  createCoupon(data: CouponCreateInput!): Coupon
  createCoupons(data: [CouponCreateInput!]!): [Coupon]
  updateCoupon(where: CouponWhereUniqueInput!, data: CouponUpdateInput!): Coupon
  updateCoupons(data: [CouponUpdateArgs!]!): [Coupon]
  deleteCoupon(where: CouponWhereUniqueInput!): Coupon
  deleteCoupons(where: [CouponWhereUniqueInput!]!): [Coupon]
  createAudit(data: AuditCreateInput!): Audit
  createAudits(data: [AuditCreateInput!]!): [Audit]
  updateAudit(where: AuditWhereUniqueInput!, data: AuditUpdateInput!): Audit
  updateAudits(data: [AuditUpdateArgs!]!): [Audit]
  deleteAudit(where: AuditWhereUniqueInput!): Audit
  deleteAudits(where: [AuditWhereUniqueInput!]!): [Audit]
  createKyc(data: KycCreateInput!): Kyc
  createKycs(data: [KycCreateInput!]!): [Kyc]
  updateKyc(where: KycWhereUniqueInput!, data: KycUpdateInput!): Kyc
  updateKycs(data: [KycUpdateArgs!]!): [Kyc]
  deleteKyc(where: KycWhereUniqueInput!): Kyc
  deleteKycs(where: [KycWhereUniqueInput!]!): [Kyc]
  createNotification(data: NotificationCreateInput!): Notification
  createNotifications(data: [NotificationCreateInput!]!): [Notification]
  updateNotification(
    where: NotificationWhereUniqueInput!
    data: NotificationUpdateInput!
  ): Notification
  updateNotifications(data: [NotificationUpdateArgs!]!): [Notification]
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteNotifications(where: [NotificationWhereUniqueInput!]!): [Notification]
  createMarketStat(data: MarketStatCreateInput!): MarketStat
  createMarketStats(data: [MarketStatCreateInput!]!): [MarketStat]
  updateMarketStat(
    where: MarketStatWhereUniqueInput!
    data: MarketStatUpdateInput!
  ): MarketStat
  updateMarketStats(data: [MarketStatUpdateArgs!]!): [MarketStat]
  deleteMarketStat(where: MarketStatWhereUniqueInput!): MarketStat
  deleteMarketStats(where: [MarketStatWhereUniqueInput!]!): [MarketStat]
  createSocialStat(data: SocialStatCreateInput!): SocialStat
  createSocialStats(data: [SocialStatCreateInput!]!): [SocialStat]
  updateSocialStat(
    where: SocialStatWhereUniqueInput!
    data: SocialStatUpdateInput!
  ): SocialStat
  updateSocialStats(data: [SocialStatUpdateArgs!]!): [SocialStat]
  deleteSocialStat(where: SocialStatWhereUniqueInput!): SocialStat
  deleteSocialStats(where: [SocialStatWhereUniqueInput!]!): [SocialStat]
  createCustomTracker(data: CustomTrackerCreateInput!): CustomTracker
  createCustomTrackers(data: [CustomTrackerCreateInput!]!): [CustomTracker]
  updateCustomTracker(
    where: CustomTrackerWhereUniqueInput!
    data: CustomTrackerUpdateInput!
  ): CustomTracker
  updateCustomTrackers(data: [CustomTrackerUpdateArgs!]!): [CustomTracker]
  deleteCustomTracker(where: CustomTrackerWhereUniqueInput!): CustomTracker
  deleteCustomTrackers(
    where: [CustomTrackerWhereUniqueInput!]!
  ): [CustomTracker]
  createLiquidityPair(data: LiquidityPairCreateInput!): LiquidityPair
  createLiquidityPairs(data: [LiquidityPairCreateInput!]!): [LiquidityPair]
  updateLiquidityPair(
    where: LiquidityPairWhereUniqueInput!
    data: LiquidityPairUpdateInput!
  ): LiquidityPair
  updateLiquidityPairs(data: [LiquidityPairUpdateArgs!]!): [LiquidityPair]
  deleteLiquidityPair(where: LiquidityPairWhereUniqueInput!): LiquidityPair
  deleteLiquidityPairs(
    where: [LiquidityPairWhereUniqueInput!]!
  ): [LiquidityPair]
  createTag(data: TagCreateInput!): Tag
  createTags(data: [TagCreateInput!]!): [Tag]
  updateTag(where: TagWhereUniqueInput!, data: TagUpdateInput!): Tag
  updateTags(data: [TagUpdateArgs!]!): [Tag]
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteTags(where: [TagWhereUniqueInput!]!): [Tag]
  createExchange(data: ExchangeCreateInput!): Exchange
  createExchanges(data: [ExchangeCreateInput!]!): [Exchange]
  updateExchange(
    where: ExchangeWhereUniqueInput!
    data: ExchangeUpdateInput!
  ): Exchange
  updateExchanges(data: [ExchangeUpdateArgs!]!): [Exchange]
  deleteExchange(where: ExchangeWhereUniqueInput!): Exchange
  deleteExchanges(where: [ExchangeWhereUniqueInput!]!): [Exchange]
  createToken(data: TokenCreateInput!): Token
  createTokens(data: [TokenCreateInput!]!): [Token]
  updateToken(where: TokenWhereUniqueInput!, data: TokenUpdateInput!): Token
  updateTokens(data: [TokenUpdateArgs!]!): [Token]
  deleteToken(where: TokenWhereUniqueInput!): Token
  deleteTokens(where: [TokenWhereUniqueInput!]!): [Token]
  createNetwork(data: NetworkCreateInput!): Network
  createNetworks(data: [NetworkCreateInput!]!): [Network]
  updateNetwork(
    where: NetworkWhereUniqueInput!
    data: NetworkUpdateInput!
  ): Network
  updateNetworks(data: [NetworkUpdateArgs!]!): [Network]
  deleteNetwork(where: NetworkWhereUniqueInput!): Network
  deleteNetworks(where: [NetworkWhereUniqueInput!]!): [Network]
  createStableLiquidityPair(
    data: StableLiquidityPairCreateInput!
  ): StableLiquidityPair
  createStableLiquidityPairs(
    data: [StableLiquidityPairCreateInput!]!
  ): [StableLiquidityPair]
  updateStableLiquidityPair(
    where: StableLiquidityPairWhereUniqueInput!
    data: StableLiquidityPairUpdateInput!
  ): StableLiquidityPair
  updateStableLiquidityPairs(
    data: [StableLiquidityPairUpdateArgs!]!
  ): [StableLiquidityPair]
  deleteStableLiquidityPair(
    where: StableLiquidityPairWhereUniqueInput!
  ): StableLiquidityPair
  deleteStableLiquidityPairs(
    where: [StableLiquidityPairWhereUniqueInput!]!
  ): [StableLiquidityPair]
  createDiscordConfig(data: DiscordConfigCreateInput!): DiscordConfig
  createDiscordConfigs(data: [DiscordConfigCreateInput!]!): [DiscordConfig]
  updateDiscordConfig(
    where: DiscordConfigWhereUniqueInput!
    data: DiscordConfigUpdateInput!
  ): DiscordConfig
  updateDiscordConfigs(data: [DiscordConfigUpdateArgs!]!): [DiscordConfig]
  deleteDiscordConfig(where: DiscordConfigWhereUniqueInput!): DiscordConfig
  deleteDiscordConfigs(
    where: [DiscordConfigWhereUniqueInput!]!
  ): [DiscordConfig]
  createDiscordEvent(data: DiscordEventCreateInput!): DiscordEvent
  createDiscordEvents(data: [DiscordEventCreateInput!]!): [DiscordEvent]
  updateDiscordEvent(
    where: DiscordEventWhereUniqueInput!
    data: DiscordEventUpdateInput!
  ): DiscordEvent
  updateDiscordEvents(data: [DiscordEventUpdateArgs!]!): [DiscordEvent]
  deleteDiscordEvent(where: DiscordEventWhereUniqueInput!): DiscordEvent
  deleteDiscordEvents(where: [DiscordEventWhereUniqueInput!]!): [DiscordEvent]
  createDiscordAnnouncement(
    data: DiscordAnnouncementCreateInput!
  ): DiscordAnnouncement
  createDiscordAnnouncements(
    data: [DiscordAnnouncementCreateInput!]!
  ): [DiscordAnnouncement]
  updateDiscordAnnouncement(
    where: DiscordAnnouncementWhereUniqueInput!
    data: DiscordAnnouncementUpdateInput!
  ): DiscordAnnouncement
  updateDiscordAnnouncements(
    data: [DiscordAnnouncementUpdateArgs!]!
  ): [DiscordAnnouncement]
  deleteDiscordAnnouncement(
    where: DiscordAnnouncementWhereUniqueInput!
  ): DiscordAnnouncement
  deleteDiscordAnnouncements(
    where: [DiscordAnnouncementWhereUniqueInput!]!
  ): [DiscordAnnouncement]
  createDiscordBot(data: DiscordBotCreateInput!): DiscordBot
  createDiscordBots(data: [DiscordBotCreateInput!]!): [DiscordBot]
  updateDiscordBot(
    where: DiscordBotWhereUniqueInput!
    data: DiscordBotUpdateInput!
  ): DiscordBot
  updateDiscordBots(data: [DiscordBotUpdateArgs!]!): [DiscordBot]
  deleteDiscordBot(where: DiscordBotWhereUniqueInput!): DiscordBot
  deleteDiscordBots(where: [DiscordBotWhereUniqueInput!]!): [DiscordBot]
  createContent(data: ContentCreateInput!): Content
  createContents(data: [ContentCreateInput!]!): [Content]
  updateContent(
    where: ContentWhereUniqueInput!
    data: ContentUpdateInput!
  ): Content
  updateContents(data: [ContentUpdateArgs!]!): [Content]
  deleteContent(where: ContentWhereUniqueInput!): Content
  deleteContents(where: [ContentWhereUniqueInput!]!): [Content]
  createComment(data: CommentCreateInput!): Comment
  createComments(data: [CommentCreateInput!]!): [Comment]
  updateComment(
    where: CommentWhereUniqueInput!
    data: CommentUpdateInput!
  ): Comment
  updateComments(data: [CommentUpdateArgs!]!): [Comment]
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteComments(where: [CommentWhereUniqueInput!]!): [Comment]
  createContentBlock(data: ContentBlockCreateInput!): ContentBlock
  createContentBlocks(data: [ContentBlockCreateInput!]!): [ContentBlock]
  updateContentBlock(
    where: ContentBlockWhereUniqueInput!
    data: ContentBlockUpdateInput!
  ): ContentBlock
  updateContentBlocks(data: [ContentBlockUpdateArgs!]!): [ContentBlock]
  deleteContentBlock(where: ContentBlockWhereUniqueInput!): ContentBlock
  deleteContentBlocks(where: [ContentBlockWhereUniqueInput!]!): [ContentBlock]
  createContentType(data: ContentTypeCreateInput!): ContentType
  createContentTypes(data: [ContentTypeCreateInput!]!): [ContentType]
  updateContentType(
    where: ContentTypeWhereUniqueInput!
    data: ContentTypeUpdateInput!
  ): ContentType
  updateContentTypes(data: [ContentTypeUpdateArgs!]!): [ContentType]
  deleteContentType(where: ContentTypeWhereUniqueInput!): ContentType
  deleteContentTypes(where: [ContentTypeWhereUniqueInput!]!): [ContentType]
  createImage(data: ImageCreateInput!): Image
  createImages(data: [ImageCreateInput!]!): [Image]
  updateImage(where: ImageWhereUniqueInput!, data: ImageUpdateInput!): Image
  updateImages(data: [ImageUpdateArgs!]!): [Image]
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteImages(where: [ImageWhereUniqueInput!]!): [Image]
  createBlock(data: BlockCreateInput!): Block
  createBlocks(data: [BlockCreateInput!]!): [Block]
  updateBlock(where: BlockWhereUniqueInput!, data: BlockUpdateInput!): Block
  updateBlocks(data: [BlockUpdateArgs!]!): [Block]
  deleteBlock(where: BlockWhereUniqueInput!): Block
  deleteBlocks(where: [BlockWhereUniqueInput!]!): [Block]
  createTransfer(data: TransferCreateInput!): Transfer
  createTransfers(data: [TransferCreateInput!]!): [Transfer]
  updateTransfer(
    where: TransferWhereUniqueInput!
    data: TransferUpdateInput!
  ): Transfer
  updateTransfers(data: [TransferUpdateArgs!]!): [Transfer]
  deleteTransfer(where: TransferWhereUniqueInput!): Transfer
  deleteTransfers(where: [TransferWhereUniqueInput!]!): [Transfer]
  createHolder(data: HolderCreateInput!): Holder
  createHolders(data: [HolderCreateInput!]!): [Holder]
  updateHolder(where: HolderWhereUniqueInput!, data: HolderUpdateInput!): Holder
  updateHolders(data: [HolderUpdateArgs!]!): [Holder]
  deleteHolder(where: HolderWhereUniqueInput!): Holder
  deleteHolders(where: [HolderWhereUniqueInput!]!): [Holder]
  createProvider(data: ProviderCreateInput!): Provider
  createProviders(data: [ProviderCreateInput!]!): [Provider]
  updateProvider(
    where: ProviderWhereUniqueInput!
    data: ProviderUpdateInput!
  ): Provider
  updateProviders(data: [ProviderUpdateArgs!]!): [Provider]
  deleteProvider(where: ProviderWhereUniqueInput!): Provider
  deleteProviders(where: [ProviderWhereUniqueInput!]!): [Provider]
  createAuditor(data: AuditorCreateInput!): Auditor
  createAuditors(data: [AuditorCreateInput!]!): [Auditor]
  updateAuditor(
    where: AuditorWhereUniqueInput!
    data: AuditorUpdateInput!
  ): Auditor
  updateAuditors(data: [AuditorUpdateArgs!]!): [Auditor]
  deleteAuditor(where: AuditorWhereUniqueInput!): Auditor
  deleteAuditors(where: [AuditorWhereUniqueInput!]!): [Auditor]
  createKycGroup(data: KycGroupCreateInput!): KycGroup
  createKycGroups(data: [KycGroupCreateInput!]!): [KycGroup]
  updateKycGroup(
    where: KycGroupWhereUniqueInput!
    data: KycGroupUpdateInput!
  ): KycGroup
  updateKycGroups(data: [KycGroupUpdateArgs!]!): [KycGroup]
  deleteKycGroup(where: KycGroupWhereUniqueInput!): KycGroup
  deleteKycGroups(where: [KycGroupWhereUniqueInput!]!): [KycGroup]
  createTransparencyRating(
    data: TransparencyRatingCreateInput!
  ): TransparencyRating
  createTransparencyRatings(
    data: [TransparencyRatingCreateInput!]!
  ): [TransparencyRating]
  updateTransparencyRating(
    where: TransparencyRatingWhereUniqueInput!
    data: TransparencyRatingUpdateInput!
  ): TransparencyRating
  updateTransparencyRatings(
    data: [TransparencyRatingUpdateArgs!]!
  ): [TransparencyRating]
  deleteTransparencyRating(
    where: TransparencyRatingWhereUniqueInput!
  ): TransparencyRating
  deleteTransparencyRatings(
    where: [TransparencyRatingWhereUniqueInput!]!
  ): [TransparencyRating]
  createMarketingCampaign(
    data: MarketingCampaignCreateInput!
  ): MarketingCampaign
  createMarketingCampaigns(
    data: [MarketingCampaignCreateInput!]!
  ): [MarketingCampaign]
  updateMarketingCampaign(
    where: MarketingCampaignWhereUniqueInput!
    data: MarketingCampaignUpdateInput!
  ): MarketingCampaign
  updateMarketingCampaigns(
    data: [MarketingCampaignUpdateArgs!]!
  ): [MarketingCampaign]
  deleteMarketingCampaign(
    where: MarketingCampaignWhereUniqueInput!
  ): MarketingCampaign
  deleteMarketingCampaigns(
    where: [MarketingCampaignWhereUniqueInput!]!
  ): [MarketingCampaign]
  createMarketingTrackerResult(
    data: MarketingTrackerResultCreateInput!
  ): MarketingTrackerResult
  createMarketingTrackerResults(
    data: [MarketingTrackerResultCreateInput!]!
  ): [MarketingTrackerResult]
  updateMarketingTrackerResult(
    where: MarketingTrackerResultWhereUniqueInput!
    data: MarketingTrackerResultUpdateInput!
  ): MarketingTrackerResult
  updateMarketingTrackerResults(
    data: [MarketingTrackerResultUpdateArgs!]!
  ): [MarketingTrackerResult]
  deleteMarketingTrackerResult(
    where: MarketingTrackerResultWhereUniqueInput!
  ): MarketingTrackerResult
  deleteMarketingTrackerResults(
    where: [MarketingTrackerResultWhereUniqueInput!]!
  ): [MarketingTrackerResult]
  createCart(data: CartCreateInput!): Cart
  createCarts(data: [CartCreateInput!]!): [Cart]
  updateCart(where: CartWhereUniqueInput!, data: CartUpdateInput!): Cart
  updateCarts(data: [CartUpdateArgs!]!): [Cart]
  deleteCart(where: CartWhereUniqueInput!): Cart
  deleteCarts(where: [CartWhereUniqueInput!]!): [Cart]
  createCartItem(data: CartItemCreateInput!): CartItem
  createCartItems(data: [CartItemCreateInput!]!): [CartItem]
  updateCartItem(
    where: CartItemWhereUniqueInput!
    data: CartItemUpdateInput!
  ): CartItem
  updateCartItems(data: [CartItemUpdateArgs!]!): [CartItem]
  deleteCartItem(where: CartItemWhereUniqueInput!): CartItem
  deleteCartItems(where: [CartItemWhereUniqueInput!]!): [CartItem]
  createOrder(data: OrderCreateInput!): Order
  createOrders(data: [OrderCreateInput!]!): [Order]
  updateOrder(where: OrderWhereUniqueInput!, data: OrderUpdateInput!): Order
  updateOrders(data: [OrderUpdateArgs!]!): [Order]
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteOrders(where: [OrderWhereUniqueInput!]!): [Order]
  createOrderItem(data: OrderItemCreateInput!): OrderItem
  createOrderItems(data: [OrderItemCreateInput!]!): [OrderItem]
  updateOrderItem(
    where: OrderItemWhereUniqueInput!
    data: OrderItemUpdateInput!
  ): OrderItem
  updateOrderItems(data: [OrderItemUpdateArgs!]!): [OrderItem]
  deleteOrderItem(where: OrderItemWhereUniqueInput!): OrderItem
  deleteOrderItems(where: [OrderItemWhereUniqueInput!]!): [OrderItem]
  createVote(data: VoteCreateInput!): Vote
  createVotes(data: [VoteCreateInput!]!): [Vote]
  updateVote(where: VoteWhereUniqueInput!, data: VoteUpdateInput!): Vote
  updateVotes(data: [VoteUpdateArgs!]!): [Vote]
  deleteVote(where: VoteWhereUniqueInput!): Vote
  deleteVotes(where: [VoteWhereUniqueInput!]!): [Vote]
  createQuiz(data: QuizCreateInput!): Quiz
  createQuizzes(data: [QuizCreateInput!]!): [Quiz]
  updateQuiz(where: QuizWhereUniqueInput!, data: QuizUpdateInput!): Quiz
  updateQuizzes(data: [QuizUpdateArgs!]!): [Quiz]
  deleteQuiz(where: QuizWhereUniqueInput!): Quiz
  deleteQuizzes(where: [QuizWhereUniqueInput!]!): [Quiz]
  createTranscription(data: TranscriptionCreateInput!): Transcription
  createTranscriptions(data: [TranscriptionCreateInput!]!): [Transcription]
  updateTranscription(
    where: TranscriptionWhereUniqueInput!
    data: TranscriptionUpdateInput!
  ): Transcription
  updateTranscriptions(data: [TranscriptionUpdateArgs!]!): [Transcription]
  deleteTranscription(where: TranscriptionWhereUniqueInput!): Transcription
  deleteTranscriptions(
    where: [TranscriptionWhereUniqueInput!]!
  ): [Transcription]
  createEmailList(data: EmailListCreateInput!): EmailList
  createEmailLists(data: [EmailListCreateInput!]!): [EmailList]
  updateEmailList(
    where: EmailListWhereUniqueInput!
    data: EmailListUpdateInput!
  ): EmailList
  updateEmailLists(data: [EmailListUpdateArgs!]!): [EmailList]
  deleteEmailList(where: EmailListWhereUniqueInput!): EmailList
  deleteEmailLists(where: [EmailListWhereUniqueInput!]!): [EmailList]
  createServiceToken(data: ServiceTokenCreateInput!): ServiceToken
  createServiceTokens(data: [ServiceTokenCreateInput!]!): [ServiceToken]
  updateServiceToken(
    where: ServiceTokenWhereUniqueInput!
    data: ServiceTokenUpdateInput!
  ): ServiceToken
  updateServiceTokens(data: [ServiceTokenUpdateArgs!]!): [ServiceToken]
  deleteServiceToken(where: ServiceTokenWhereUniqueInput!): ServiceToken
  deleteServiceTokens(where: [ServiceTokenWhereUniqueInput!]!): [ServiceToken]
  createServiceTokenUsage(
    data: ServiceTokenUsageCreateInput!
  ): ServiceTokenUsage
  createServiceTokenUsages(
    data: [ServiceTokenUsageCreateInput!]!
  ): [ServiceTokenUsage]
  updateServiceTokenUsage(
    where: ServiceTokenUsageWhereUniqueInput!
    data: ServiceTokenUsageUpdateInput!
  ): ServiceTokenUsage
  updateServiceTokenUsages(
    data: [ServiceTokenUsageUpdateArgs!]!
  ): [ServiceTokenUsage]
  deleteServiceTokenUsage(
    where: ServiceTokenUsageWhereUniqueInput!
  ): ServiceTokenUsage
  deleteServiceTokenUsages(
    where: [ServiceTokenUsageWhereUniqueInput!]!
  ): [ServiceTokenUsage]
  createAccount(data: AccountCreateInput!): Account
  createAccounts(data: [AccountCreateInput!]!): [Account]
  updateAccount(
    where: AccountWhereUniqueInput!
    data: AccountUpdateInput!
  ): Account
  updateAccounts(data: [AccountUpdateArgs!]!): [Account]
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteAccounts(where: [AccountWhereUniqueInput!]!): [Account]
  createSession(data: SessionCreateInput!): Session
  createSessions(data: [SessionCreateInput!]!): [Session]
  updateSession(
    where: SessionWhereUniqueInput!
    data: SessionUpdateInput!
  ): Session
  updateSessions(data: [SessionUpdateArgs!]!): [Session]
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteSessions(where: [SessionWhereUniqueInput!]!): [Session]
  createVerificationToken(
    data: VerificationTokenCreateInput!
  ): VerificationToken
  createVerificationTokens(
    data: [VerificationTokenCreateInput!]!
  ): [VerificationToken]
  updateVerificationToken(
    where: VerificationTokenWhereUniqueInput!
    data: VerificationTokenUpdateInput!
  ): VerificationToken
  updateVerificationTokens(
    data: [VerificationTokenUpdateArgs!]!
  ): [VerificationToken]
  deleteVerificationToken(
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken
  deleteVerificationTokens(
    where: [VerificationTokenWhereUniqueInput!]!
  ): [VerificationToken]
  createUserAuth(data: UserAuthCreateInput!): UserAuth
  createUserAuths(data: [UserAuthCreateInput!]!): [UserAuth]
  updateUserAuth(
    where: UserAuthWhereUniqueInput!
    data: UserAuthUpdateInput!
  ): UserAuth
  updateUserAuths(data: [UserAuthUpdateArgs!]!): [UserAuth]
  deleteUserAuth(where: UserAuthWhereUniqueInput!): UserAuth
  deleteUserAuths(where: [UserAuthWhereUniqueInput!]!): [UserAuth]
  endSession: Boolean!
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
  sendUserPasswordResetLink(email: String!): Boolean!
  redeemUserPasswordResetToken(
    email: String!
    token: String!
    password: String!
  ): RedeemUserPasswordResetTokenResult
}

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type RedeemUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

enum PasswordResetRedemptionErrorCode {
  FAILURE
  TOKEN_EXPIRED
  TOKEN_REDEEMED
}

type Query {
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  subscriptions(
    where: SubscriptionWhereInput! = {}
    orderBy: [SubscriptionOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Subscription!]
  subscription(where: SubscriptionWhereUniqueInput!): Subscription
  subscriptionsCount(where: SubscriptionWhereInput! = {}): Int
  products(
    where: ProductWhereInput! = {}
    orderBy: [ProductOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Product!]
  product(where: ProductWhereUniqueInput!): Product
  productsCount(where: ProductWhereInput! = {}): Int
  roles(
    where: RoleWhereInput! = {}
    orderBy: [RoleOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Role!]
  role(where: RoleWhereUniqueInput!): Role
  rolesCount(where: RoleWhereInput! = {}): Int
  projects(
    where: ProjectWhereInput! = {}
    orderBy: [ProjectOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Project!]
  project(where: ProjectWhereUniqueInput!): Project
  projectsCount(where: ProjectWhereInput! = {}): Int
  paymentPlans(
    where: PaymentPlanWhereInput! = {}
    orderBy: [PaymentPlanOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [PaymentPlan!]
  paymentPlan(where: PaymentPlanWhereUniqueInput!): PaymentPlan
  paymentPlansCount(where: PaymentPlanWhereInput! = {}): Int
  coupons(
    where: CouponWhereInput! = {}
    orderBy: [CouponOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Coupon!]
  coupon(where: CouponWhereUniqueInput!): Coupon
  couponsCount(where: CouponWhereInput! = {}): Int
  audits(
    where: AuditWhereInput! = {}
    orderBy: [AuditOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Audit!]
  audit(where: AuditWhereUniqueInput!): Audit
  auditsCount(where: AuditWhereInput! = {}): Int
  kycs(
    where: KycWhereInput! = {}
    orderBy: [KycOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Kyc!]
  kyc(where: KycWhereUniqueInput!): Kyc
  kycsCount(where: KycWhereInput! = {}): Int
  notifications(
    where: NotificationWhereInput! = {}
    orderBy: [NotificationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Notification!]
  notification(where: NotificationWhereUniqueInput!): Notification
  notificationsCount(where: NotificationWhereInput! = {}): Int
  marketStats(
    where: MarketStatWhereInput! = {}
    orderBy: [MarketStatOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [MarketStat!]
  marketStat(where: MarketStatWhereUniqueInput!): MarketStat
  marketStatsCount(where: MarketStatWhereInput! = {}): Int
  socialStats(
    where: SocialStatWhereInput! = {}
    orderBy: [SocialStatOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [SocialStat!]
  socialStat(where: SocialStatWhereUniqueInput!): SocialStat
  socialStatsCount(where: SocialStatWhereInput! = {}): Int
  customTrackers(
    where: CustomTrackerWhereInput! = {}
    orderBy: [CustomTrackerOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [CustomTracker!]
  customTracker(where: CustomTrackerWhereUniqueInput!): CustomTracker
  customTrackersCount(where: CustomTrackerWhereInput! = {}): Int
  liquidityPairs(
    where: LiquidityPairWhereInput! = {}
    orderBy: [LiquidityPairOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [LiquidityPair!]
  liquidityPair(where: LiquidityPairWhereUniqueInput!): LiquidityPair
  liquidityPairsCount(where: LiquidityPairWhereInput! = {}): Int
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tag(where: TagWhereUniqueInput!): Tag
  tagsCount(where: TagWhereInput! = {}): Int
  exchanges(
    where: ExchangeWhereInput! = {}
    orderBy: [ExchangeOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Exchange!]
  exchange(where: ExchangeWhereUniqueInput!): Exchange
  exchangesCount(where: ExchangeWhereInput! = {}): Int
  tokens(
    where: TokenWhereInput! = {}
    orderBy: [TokenOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Token!]
  token(where: TokenWhereUniqueInput!): Token
  tokensCount(where: TokenWhereInput! = {}): Int
  networks(
    where: NetworkWhereInput! = {}
    orderBy: [NetworkOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Network!]
  network(where: NetworkWhereUniqueInput!): Network
  networksCount(where: NetworkWhereInput! = {}): Int
  stableLiquidityPairs(
    where: StableLiquidityPairWhereInput! = {}
    orderBy: [StableLiquidityPairOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [StableLiquidityPair!]
  stableLiquidityPair(
    where: StableLiquidityPairWhereUniqueInput!
  ): StableLiquidityPair
  stableLiquidityPairsCount(where: StableLiquidityPairWhereInput! = {}): Int
  discordConfigs(
    where: DiscordConfigWhereInput! = {}
    orderBy: [DiscordConfigOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [DiscordConfig!]
  discordConfig(where: DiscordConfigWhereUniqueInput!): DiscordConfig
  discordConfigsCount(where: DiscordConfigWhereInput! = {}): Int
  discordEvents(
    where: DiscordEventWhereInput! = {}
    orderBy: [DiscordEventOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [DiscordEvent!]
  discordEvent(where: DiscordEventWhereUniqueInput!): DiscordEvent
  discordEventsCount(where: DiscordEventWhereInput! = {}): Int
  discordAnnouncements(
    where: DiscordAnnouncementWhereInput! = {}
    orderBy: [DiscordAnnouncementOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [DiscordAnnouncement!]
  discordAnnouncement(
    where: DiscordAnnouncementWhereUniqueInput!
  ): DiscordAnnouncement
  discordAnnouncementsCount(where: DiscordAnnouncementWhereInput! = {}): Int
  discordBots(
    where: DiscordBotWhereInput! = {}
    orderBy: [DiscordBotOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [DiscordBot!]
  discordBot(where: DiscordBotWhereUniqueInput!): DiscordBot
  discordBotsCount(where: DiscordBotWhereInput! = {}): Int
  contents(
    where: ContentWhereInput! = {}
    orderBy: [ContentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Content!]
  content(where: ContentWhereUniqueInput!): Content
  contentsCount(where: ContentWhereInput! = {}): Int
  comments(
    where: CommentWhereInput! = {}
    orderBy: [CommentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Comment!]
  comment(where: CommentWhereUniqueInput!): Comment
  commentsCount(where: CommentWhereInput! = {}): Int
  contentBlocks(
    where: ContentBlockWhereInput! = {}
    orderBy: [ContentBlockOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [ContentBlock!]
  contentBlock(where: ContentBlockWhereUniqueInput!): ContentBlock
  contentBlocksCount(where: ContentBlockWhereInput! = {}): Int
  contentTypes(
    where: ContentTypeWhereInput! = {}
    orderBy: [ContentTypeOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [ContentType!]
  contentType(where: ContentTypeWhereUniqueInput!): ContentType
  contentTypesCount(where: ContentTypeWhereInput! = {}): Int
  images(
    where: ImageWhereInput! = {}
    orderBy: [ImageOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Image!]
  image(where: ImageWhereUniqueInput!): Image
  imagesCount(where: ImageWhereInput! = {}): Int
  blocks(
    where: BlockWhereInput! = {}
    orderBy: [BlockOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Block!]
  block(where: BlockWhereUniqueInput!): Block
  blocksCount(where: BlockWhereInput! = {}): Int
  transfers(
    where: TransferWhereInput! = {}
    orderBy: [TransferOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Transfer!]
  transfer(where: TransferWhereUniqueInput!): Transfer
  transfersCount(where: TransferWhereInput! = {}): Int
  holders(
    where: HolderWhereInput! = {}
    orderBy: [HolderOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Holder!]
  holder(where: HolderWhereUniqueInput!): Holder
  holdersCount(where: HolderWhereInput! = {}): Int
  providers(
    where: ProviderWhereInput! = {}
    orderBy: [ProviderOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Provider!]
  provider(where: ProviderWhereUniqueInput!): Provider
  providersCount(where: ProviderWhereInput! = {}): Int
  auditors(
    where: AuditorWhereInput! = {}
    orderBy: [AuditorOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Auditor!]
  auditor(where: AuditorWhereUniqueInput!): Auditor
  auditorsCount(where: AuditorWhereInput! = {}): Int
  kycGroups(
    where: KycGroupWhereInput! = {}
    orderBy: [KycGroupOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [KycGroup!]
  kycGroup(where: KycGroupWhereUniqueInput!): KycGroup
  kycGroupsCount(where: KycGroupWhereInput! = {}): Int
  transparencyRatings(
    where: TransparencyRatingWhereInput! = {}
    orderBy: [TransparencyRatingOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [TransparencyRating!]
  transparencyRating(
    where: TransparencyRatingWhereUniqueInput!
  ): TransparencyRating
  transparencyRatingsCount(where: TransparencyRatingWhereInput! = {}): Int
  marketingCampaigns(
    where: MarketingCampaignWhereInput! = {}
    orderBy: [MarketingCampaignOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [MarketingCampaign!]
  marketingCampaign(
    where: MarketingCampaignWhereUniqueInput!
  ): MarketingCampaign
  marketingCampaignsCount(where: MarketingCampaignWhereInput! = {}): Int
  marketingTrackerResults(
    where: MarketingTrackerResultWhereInput! = {}
    orderBy: [MarketingTrackerResultOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [MarketingTrackerResult!]
  marketingTrackerResult(
    where: MarketingTrackerResultWhereUniqueInput!
  ): MarketingTrackerResult
  marketingTrackerResultsCount(
    where: MarketingTrackerResultWhereInput! = {}
  ): Int
  carts(
    where: CartWhereInput! = {}
    orderBy: [CartOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Cart!]
  cart(where: CartWhereUniqueInput!): Cart
  cartsCount(where: CartWhereInput! = {}): Int
  cartItems(
    where: CartItemWhereInput! = {}
    orderBy: [CartItemOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [CartItem!]
  cartItem(where: CartItemWhereUniqueInput!): CartItem
  cartItemsCount(where: CartItemWhereInput! = {}): Int
  orders(
    where: OrderWhereInput! = {}
    orderBy: [OrderOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Order!]
  order(where: OrderWhereUniqueInput!): Order
  ordersCount(where: OrderWhereInput! = {}): Int
  orderItems(
    where: OrderItemWhereInput! = {}
    orderBy: [OrderItemOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [OrderItem!]
  orderItem(where: OrderItemWhereUniqueInput!): OrderItem
  orderItemsCount(where: OrderItemWhereInput! = {}): Int
  votes(
    where: VoteWhereInput! = {}
    orderBy: [VoteOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Vote!]
  vote(where: VoteWhereUniqueInput!): Vote
  votesCount(where: VoteWhereInput! = {}): Int
  quizzes(
    where: QuizWhereInput! = {}
    orderBy: [QuizOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Quiz!]
  quiz(where: QuizWhereUniqueInput!): Quiz
  quizzesCount(where: QuizWhereInput! = {}): Int
  transcriptions(
    where: TranscriptionWhereInput! = {}
    orderBy: [TranscriptionOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Transcription!]
  transcription(where: TranscriptionWhereUniqueInput!): Transcription
  transcriptionsCount(where: TranscriptionWhereInput! = {}): Int
  emailLists(
    where: EmailListWhereInput! = {}
    orderBy: [EmailListOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [EmailList!]
  emailList(where: EmailListWhereUniqueInput!): EmailList
  emailListsCount(where: EmailListWhereInput! = {}): Int
  serviceTokens(
    where: ServiceTokenWhereInput! = {}
    orderBy: [ServiceTokenOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [ServiceToken!]
  serviceToken(where: ServiceTokenWhereUniqueInput!): ServiceToken
  serviceTokensCount(where: ServiceTokenWhereInput! = {}): Int
  serviceTokenUsages(
    where: ServiceTokenUsageWhereInput! = {}
    orderBy: [ServiceTokenUsageOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [ServiceTokenUsage!]
  serviceTokenUsage(
    where: ServiceTokenUsageWhereUniqueInput!
  ): ServiceTokenUsage
  serviceTokenUsagesCount(where: ServiceTokenUsageWhereInput! = {}): Int
  accounts(
    where: AccountWhereInput! = {}
    orderBy: [AccountOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Account!]
  account(where: AccountWhereUniqueInput!): Account
  accountsCount(where: AccountWhereInput! = {}): Int
  sessions(
    where: SessionWhereInput! = {}
    orderBy: [SessionOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Session!]
  session(where: SessionWhereUniqueInput!): Session
  sessionsCount(where: SessionWhereInput! = {}): Int
  verificationTokens(
    where: VerificationTokenWhereInput! = {}
    orderBy: [VerificationTokenOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [VerificationToken!]
  verificationToken(
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken
  verificationTokensCount(where: VerificationTokenWhereInput! = {}): Int
  userAuths(
    where: UserAuthWhereInput! = {}
    orderBy: [UserAuthOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [UserAuth!]
  userAuth(where: UserAuthWhereUniqueInput!): UserAuth
  userAuthsCount(where: UserAuthWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
  validateUserPasswordResetToken(
    email: String!
    token: String!
  ): ValidateUserPasswordResetTokenResult
}

union AuthenticatedItem = User

type ValidateUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
